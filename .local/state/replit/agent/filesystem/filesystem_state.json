{"file_contents":{"src/middleware/rateLimit.ts":{"content":"import rateLimit from 'express-rate-limit';\n\nexport const rateLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 100,\n  standardHeaders: true,\n  legacyHeaders: false,\n  message: {\n    success: false,\n    error: {\n      message: 'Too many requests from this IP, please try again later.',\n      code: 'RATE_LIMIT_EXCEEDED',\n    },\n  },\n});\n\nexport const strictRateLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 10,\n  standardHeaders: true,\n  legacyHeaders: false,\n  message: {\n    success: false,\n    error: {\n      message: 'Too many requests, please try again later.',\n      code: 'RATE_LIMIT_EXCEEDED',\n    },\n  },\n});\n","size_bytes":636},"src/modules/profile/profile.types.ts":{"content":"export interface ProfileData {\n  id: string;\n  userId: string;\n  displayName: string;\n  headline?: string;\n  about?: string;\n  gender?: string;\n  dob?: Date;\n  location?: any;\n  published: boolean;\n  completeness: number;\n  photos?: PhotoData[];\n  preferences?: PreferenceData;\n  createdAt: Date;\n  updatedAt: Date;\n  deletedAt?: Date;\n}\n\nexport interface PhotoData {\n  id: string;\n  profileId: string;\n  objectKey?: string;\n  url?: string;\n  fileSize?: number;\n  privacyLevel: string;\n  moderationStatus: string;\n  createdAt: Date;\n}\n\nexport interface PreferenceData {\n  id: string;\n  profileId: string;\n  basic?: any;\n  lifestyle?: any;\n  education?: any;\n  community?: any;\n  location?: any;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface MaskedProfile {\n  id: string;\n  displayName: string;\n  headline?: string;\n  about?: string;\n  gender?: string;\n  age?: number;\n  location?: any;\n  completeness: number;\n  photos?: PhotoData[];\n  preferences?: PreferenceData;\n}\n\nexport interface RequesterContext {\n  userId?: string;\n  isOwner?: boolean;\n  isGuardian?: boolean;\n  isPremium?: boolean;\n}\n\nexport type ProfileStep =\n  | 'about'\n  | 'demographics'\n  | 'family'\n  | 'lifestyle'\n  | 'location'\n  | 'photos-metadata'\n  | 'preferences';\n","size_bytes":1249},"README.md":{"content":"# Biye Matrimonial Platform - Backend API\n\nA secure, production-ready backend API scaffold for the Biye-style matrimonial platform. Built with Node.js, Express, TypeScript, Prisma, and comprehensive security middleware.\n\n## ðŸ—ï¸ Tech Stack\n\n- **Runtime**: Node.js 18+\n- **Framework**: Express.js\n- **Language**: TypeScript\n- **Database**: PostgreSQL (via Prisma ORM)\n- **Cache**: Redis (ioredis client)\n- **Validation**: Zod\n- **Logging**: Winston\n- **Testing**: Jest + SuperTest\n- **Security**: Helmet, CORS, Rate Limiting\n- **Code Quality**: ESLint + Prettier\n\n## ðŸ“ Project Structure\n\n```\nbackend/\nâ”œâ”€â”€ src/\nâ”‚   â”œâ”€â”€ config/\nâ”‚   â”‚   â””â”€â”€ env.ts                 # Environment validation with Zod\nâ”‚   â”œâ”€â”€ utils/\nâ”‚   â”‚   â”œâ”€â”€ logger.ts              # Winston logger with requestId\nâ”‚   â”‚   â”œâ”€â”€ response.ts            # Standardized API responses\nâ”‚   â”‚   â””â”€â”€ idempotency.ts         # Idempotency helper stub\nâ”‚   â”œâ”€â”€ middleware/\nâ”‚   â”‚   â”œâ”€â”€ helmet.ts              # Security headers\nâ”‚   â”‚   â”œâ”€â”€ rateLimit.ts           # Rate limiting (100 req/15min)\nâ”‚   â”‚   â”œâ”€â”€ cors.ts                # CORS configuration\nâ”‚   â”‚   â”œâ”€â”€ requestId.ts           # Request ID tracking\nâ”‚   â”‚   â”œâ”€â”€ errorHandler.ts        # Centralized error handling\nâ”‚   â”‚   â”œâ”€â”€ authMiddleware.ts      # JWT authentication\nâ”‚   â”‚   â””â”€â”€ validate.ts            # Request validation wrapper\nâ”‚   â”œâ”€â”€ routes/\nâ”‚   â”‚   â””â”€â”€ health.route.ts        # Health check endpoint\nâ”‚   â”œâ”€â”€ __tests__/\nâ”‚   â”‚   â””â”€â”€ health.test.ts         # Health endpoint tests\nâ”‚   â”œâ”€â”€ index.ts                   # Express app (exported for testing)\nâ”‚   â””â”€â”€ server.ts                  # Development server runner\nâ”œâ”€â”€ prisma/\nâ”‚   â””â”€â”€ schema.prisma              # Prisma schema with User model\nâ”œâ”€â”€ jest.config.js                 # Jest configuration\nâ”œâ”€â”€ .eslintrc.json                 # ESLint configuration\nâ”œâ”€â”€ .prettierrc.json               # Prettier configuration\nâ”œâ”€â”€ .env.example                   # Environment variables template\nâ””â”€â”€ README.md                      # This file\n```\n\n## ðŸš€ Getting Started\n\n### Prerequisites\n\nYou need to have the following running **locally** (not in Replit):\n\n- **PostgreSQL** database\n- **Redis** server\n\n> **Note**: This scaffold is designed for local database setup. Docker Compose or native installation of PostgreSQL and Redis must be run on your local machine.\n\n### Installation\n\n1. **Clone the repository** and navigate to the backend directory:\n   ```bash\n   cd backend\n   ```\n\n2. **Install dependencies**:\n   ```bash\n   npm install\n   ```\n\n3. **Set up environment variables**:\n   ```bash\n   cp .env.example .env\n   ```\n\n   Edit `.env` and configure your environment variables:\n   ```env\n   DATABASE_URL=postgresql://user:password@localhost:5432/biye_db\n   REDIS_URL=redis://localhost:6379\n   JWT_SECRET=your-super-secret-jwt-key-change-this-in-production\n   NODE_ENV=development\n   PORT=3000\n   LOG_LEVEL=info\n   ALLOWED_ORIGINS=http://localhost:3000\n   ```\n\n4. **Generate Prisma client**:\n   ```bash\n   npx prisma generate\n   ```\n\n5. **Run database migrations**:\n   ```bash\n   npx prisma migrate dev --name init\n   ```\n\n### Development\n\nStart the development server:\n\n```bash\nnpm run dev\n```\n\nThe API will be available at `http://localhost:3000`\n\n### Testing\n\nRun tests:\n\n```bash\nnpm test\n```\n\nRun tests with coverage:\n\n```bash\nnpm run test:coverage\n```\n\nRun linting:\n\n```bash\nnpm run lint\n```\n\nFormat code:\n\n```bash\nnpm run format\n```\n\n## ðŸ“¡ API Endpoints\n\n### Health Check\n\n**GET** `/api/health`\n\nReturns the API health status, uptime, and timestamp.\n\n**Response** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"status\": \"ok\",\n    \"uptime\": \"123s\",\n    \"timestamp\": \"2025-01-15T10:30:00.000Z\"\n  }\n}\n```\n\n## ðŸ”’ Security Features\n\n- **Helmet**: Security headers (CSP, HSTS, XSS protection, etc.)\n- **CORS**: Configurable cross-origin resource sharing\n- **Rate Limiting**: 100 requests per 15 minutes (configurable)\n- **Request ID**: Unique ID tracking for each request\n- **JWT Authentication**: Token-based authentication middleware\n- **Input Validation**: Zod schema validation for all requests\n- **Error Handling**: Centralized error handling with structured responses\n\n## ðŸ“ Environment Variables\n\n| Variable | Description | Required | Default |\n|----------|-------------|----------|---------|\n| `DATABASE_URL` | PostgreSQL connection string | Yes | - |\n| `REDIS_URL` | Redis connection string | Yes | - |\n| `JWT_SECRET` | Secret key for JWT (min 32 chars) | Yes | - |\n| `NODE_ENV` | Environment mode | No | `development` |\n| `PORT` | Server port | No | `3000` |\n| `LOG_LEVEL` | Winston log level | No | `info` |\n| `ALLOWED_ORIGINS` | Comma-separated CORS origins | Yes | - |\n\n## ðŸ§ª Testing\n\nThe project uses Jest and SuperTest for testing. Tests are located in `src/__tests__/`.\n\nExample test structure:\n```typescript\nimport request from 'supertest';\nimport { createApp } from '../index.js';\n\ndescribe('API Route', () => {\n  const app = createApp();\n  \n  it('should return expected response', async () => {\n    const response = await request(app)\n      .get('/api/endpoint')\n      .expect(200);\n    \n    expect(response.body).toMatchObject({\n      success: true,\n      data: expect.any(Object),\n    });\n  });\n});\n```\n\n## ðŸ“¦ Scripts\n\n- `npm run dev` - Start development server with hot reload\n- `npm run build` - Build for production\n- `npm start` - Start production server\n- `npm test` - Run tests\n- `npm run test:coverage` - Run tests with coverage\n- `npm run test:watch` - Run tests in watch mode\n- `npm run lint` - Run ESLint\n- `npm run lint:fix` - Fix ESLint errors\n- `npm run format` - Format code with Prettier\n- `npm run prisma:generate` - Generate Prisma client\n- `npm run prisma:migrate` - Run database migrations\n- `npm run prisma:studio` - Open Prisma Studio\n\n## ðŸ—ï¸ Architecture Decisions\n\n### Separation of Concerns\n\n- **index.ts**: Exports the Express app for testing\n- **server.ts**: Only used for development (`npm run dev`)\n- Production deployment uses the built app from `index.ts`\n\n### Error Handling\n\nAll errors are caught by the centralized error handler which:\n- Logs errors with request context\n- Returns structured error responses\n- Handles Zod validation errors\n- Prevents sensitive data leakage in production\n\n### Logging\n\nWinston logger with JSON format for production:\n- Request ID correlation\n- Structured logging for easy parsing\n- Different log levels for development vs production\n- Request/response logging with duration\n\n### Response Format\n\nAll API responses follow a consistent structure:\n\n**Success Response:**\n```json\n{\n  \"success\": true,\n  \"data\": { ... },\n  \"message\": \"Optional message\"\n}\n```\n\n**Error Response:**\n```json\n{\n  \"success\": false,\n  \"error\": {\n    \"message\": \"Error description\",\n    \"code\": \"ERROR_CODE\",\n    \"details\": { ... }\n  }\n}\n```\n\n## ðŸ”„ Database Migrations\n\nUsing Prisma for database migrations:\n\nCreate a new migration:\n```bash\nnpx prisma migrate dev --name migration_name\n```\n\nApply migrations in production:\n```bash\nnpx prisma migrate deploy\n```\n\nReset database (development only):\n```bash\nnpx prisma migrate reset\n```\n\n## ðŸš§ Next Steps\n\nThis scaffold provides the foundation. To build your matrimonial platform:\n\n1. Add user registration and login endpoints\n2. Implement profile management\n3. Add search and matching functionality\n4. Implement messaging system\n5. Add payment integration\n6. Set up email notifications\n7. Implement admin panel\n8. Add comprehensive API documentation (Swagger/OpenAPI)\n\n## ðŸ“„ License\n\nMIT\n\n## ðŸ¤ Contributing\n\n1. Fork the repository\n2. Create your feature branch\n3. Run tests and linting\n4. Commit your changes\n5. Push to the branch\n6. Create a Pull Request\n\n---\n\n**Important**: This is an API-only backend. Do not run database migrations or start Redis/PostgreSQL in Replit. All database operations must be performed locally.\n","size_bytes":8065},"src/__tests__/health.test.ts":{"content":"import request from 'supertest';\nimport { createApp } from '../index.js';\n\njest.mock('../config/env.js', () => ({\n  env: {\n    DATABASE_URL: 'postgresql://test:test@localhost:5432/test',\n    REDIS_URL: 'redis://localhost:6379',\n    JWT_SECRET: 'test-secret-key-minimum-32-characters-long',\n    NODE_ENV: 'test' as const,\n    PORT: 3000,\n    LOG_LEVEL: 'error' as const,\n    ALLOWED_ORIGINS: ['http://localhost:3000'],\n  },\n}));\n\ndescribe('Health Route', () => {\n  const app = createApp();\n\n  describe('GET /api/health', () => {\n    it('should return 200 and health status', async () => {\n      const response = await request(app)\n        .get('/api/health')\n        .expect('Content-Type', /json/)\n        .expect(200);\n\n      expect(response.body).toMatchObject({\n        success: true,\n        data: {\n          status: 'ok',\n        },\n      });\n\n      expect(response.body.data).toHaveProperty('uptime');\n      expect(response.body.data).toHaveProperty('timestamp');\n      expect(response.body.data.uptime).toMatch(/\\d+s/);\n    });\n\n    it('should include X-Request-Id header', async () => {\n      const response = await request(app)\n        .get('/api/health')\n        .expect(200);\n\n      expect(response.headers).toHaveProperty('x-request-id');\n      expect(response.headers['x-request-id']).toBeTruthy();\n    });\n\n    it('should accept custom X-Request-Id', async () => {\n      const customRequestId = 'custom-request-id-12345';\n      const response = await request(app)\n        .get('/api/health')\n        .set('X-Request-Id', customRequestId)\n        .expect(200);\n\n      expect(response.headers['x-request-id']).toBe(customRequestId);\n    });\n  });\n\n  describe('404 handling', () => {\n    it('should return 404 for unknown routes', async () => {\n      const response = await request(app)\n        .get('/api/unknown')\n        .expect('Content-Type', /json/)\n        .expect(404);\n\n      expect(response.body).toEqual({\n        success: false,\n        error: {\n          message: 'Route not found',\n          code: 'NOT_FOUND',\n        },\n      });\n    });\n  });\n});\n","size_bytes":2076},"src/modules/auth/token.service.ts":{"content":"import jwt from 'jsonwebtoken';\nimport { randomUUID } from 'crypto';\nimport bcrypt from 'bcryptjs';\nimport { env } from '../../config/env.js';\nimport { redis } from '../../config/redis.js';\nimport { logger } from '../../utils/logger.js';\nimport { JWTPayload, RefreshTokenData, TokenPair } from './auth.types.js';\n\nconst REFRESH_TOKEN_PREFIX = 'refresh_token:';\nconst TOKEN_REUSE_DETECTION_PREFIX = 'reuse_detection:';\n\nexport class TokenService {\n  generateAccessToken(userId: string, email: string, sessionId: string): string {\n    const payload: JWTPayload = {\n      userId,\n      email,\n      sessionId,\n    };\n\n    return jwt.sign(payload, env.JWT_SECRET, {\n      expiresIn: env.JWT_ACCESS_EXPIRY,\n      issuer: 'biye-api',\n      audience: 'biye-client',\n    });\n  }\n\n  async generateRefreshToken(userId: string, sessionId: string): Promise<string> {\n    const refreshToken = randomUUID();\n    const tokenHash = await bcrypt.hash(refreshToken, 10);\n\n    const tokenData: RefreshTokenData = {\n      userId,\n      sessionId,\n      tokenHash,\n      createdAt: Date.now(),\n    };\n\n    const key = `${REFRESH_TOKEN_PREFIX}${refreshToken}`;\n    const expiryInSeconds = this.parseExpiryToSeconds(env.JWT_REFRESH_EXPIRY);\n\n    await redis.setex(key, expiryInSeconds, JSON.stringify(tokenData));\n\n    logger.info('Refresh token generated', { userId, sessionId });\n\n    return refreshToken;\n  }\n\n\n  async verifyAccessToken(token: string): Promise<JWTPayload> {\n    try {\n      const payload = jwt.verify(token, env.JWT_SECRET, {\n        issuer: 'biye-api',\n        audience: 'biye-client',\n      }) as JWTPayload;\n\n      return payload;\n    } catch (error) {\n      if (error instanceof jwt.TokenExpiredError) {\n        throw new Error('Access token expired');\n      }\n      if (error instanceof jwt.JsonWebTokenError) {\n        throw new Error('Invalid access token');\n      }\n      throw new Error('Token verification failed');\n    }\n  }\n\n  async verifyRefreshToken(refreshToken: string): Promise<RefreshTokenData> {\n    const key = `${REFRESH_TOKEN_PREFIX}${refreshToken}`;\n    const data = await redis.get(key);\n\n    if (!data) {\n      // await this.detectTokenReuse(refreshToken);\n      throw new Error('Invalid or expired refresh token');\n    }\n\n    const tokenData: RefreshTokenData = JSON.parse(data);\n\n    const isValid = await bcrypt.compare(refreshToken, tokenData.tokenHash);\n    if (!isValid) {\n      throw new Error('Invalid refresh token');\n    }\n\n    return tokenData;\n  }\n\n  async rotateRefreshToken(\n    oldRefreshToken: string,\n    userId: string,\n    sessionId: string\n  ): Promise<string> {\n\n    const newRefreshToken = await this.generateRefreshToken(userId, sessionId);\n\n    await this.invalidateRefreshToken(oldRefreshToken);\n\n\n    logger.info('Refresh token rotated', { userId, sessionId });\n\n    return newRefreshToken;\n  }\n\n  async invalidateRefreshToken(refreshToken: string): Promise<void> {\n    const key = `${REFRESH_TOKEN_PREFIX}${refreshToken}`;\n    await redis.del(key);\n\n    logger.info('Refresh token invalidated');\n  }\n\n  async invalidateAllUserTokens(userId: string): Promise<void> {\n    const pattern = `${REFRESH_TOKEN_PREFIX}*`;\n    const keys = await redis.keys(pattern);\n\n    for (const key of keys) {\n      const data = await redis.get(key);\n      if (data) {\n        const tokenData: RefreshTokenData = JSON.parse(data);\n        if (tokenData.userId === userId) {\n          await redis.del(key);\n        }\n      }\n    }\n\n    logger.info('All user refresh tokens invalidated', { userId });\n  }\n\n  private async detectTokenReuse(refreshToken: string): Promise<void> {\n    const reuseKey = `${TOKEN_REUSE_DETECTION_PREFIX}${refreshToken}`;\n    const reuseAttempt = await redis.get(reuseKey);\n\n    if (reuseAttempt) {\n      logger.warn('Refresh token reuse detected', { refreshToken: refreshToken.substring(0, 8) });\n      const tokenData: RefreshTokenData = JSON.parse(reuseAttempt);\n      await this.invalidateAllUserTokens(tokenData.userId);\n      throw new Error('Token reuse detected - all sessions invalidated');\n    }\n\n    await redis.setex(reuseKey, 3600, JSON.stringify({ detected: true }));\n  }\n\n  private parseExpiryToSeconds(expiry: string): number {\n    const unit = expiry.slice(-1);\n    const value = parseInt(expiry.slice(0, -1), 10);\n\n    switch (unit) {\n      case 's':\n        return value;\n      case 'm':\n        return value * 60;\n      case 'h':\n        return value * 3600;\n      case 'd':\n        return value * 86400;\n      default:\n        return 604800;\n    }\n  }\n}\n\nexport const tokenService = new TokenService();\n","size_bytes":4577},"src/middleware/requestId.ts":{"content":"import { Request, Response, NextFunction } from 'express';\nimport { randomUUID } from 'crypto';\n\ndeclare global {\n  namespace Express {\n    interface Request {\n      requestId: string;\n    }\n  }\n}\n\nexport function requestIdMiddleware(req: Request, res: Response, next: NextFunction): void {\n  const requestId = (req.headers['x-request-id'] as string) || randomUUID();\n  req.requestId = requestId;\n  res.setHeader('X-Request-Id', requestId);\n  next();\n}\n","size_bytes":453},"src/modules/auth/auth.routes.ts":{"content":"import { Router } from 'express';\nimport rateLimit from 'express-rate-limit';\nimport { authController } from './auth.controller.js';\nimport { validate } from '../../middleware/validate.js';\nimport { RegisterSchema, VerifyOTPSchema, LoginSchema } from './auth.dto.js';\nimport { authenticateToken } from '../../middleware/authMiddleware.js';\n\nconst router = Router();\n\nconst otpLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 10,\n  message: 'Too many OTP requests from this IP, please try again after 15 minutes',\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\nconst authLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 10,\n  message: 'Too many authentication attempts from this IP, please try again after 15 minutes',\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\nrouter.post('/register', otpLimiter, validate(RegisterSchema), authController.register.bind(authController));\n\nrouter.post('/verify', authLimiter, validate(VerifyOTPSchema), authController.verify.bind(authController));\n\nrouter.post('/login', otpLimiter, validate(LoginSchema), authController.login.bind(authController));\n\nrouter.post('/refresh', authLimiter, authController.refresh.bind(authController));\n\nrouter.post('/logout', authenticateToken, authController.logout.bind(authController));\n\nrouter.get('/me', authenticateToken, authController.me.bind(authController));\n\nexport default router;\n","size_bytes":1391},"openapi-auth.yaml":{"content":"openapi: 3.0.3\ninfo:\n  title: Biye Backend API - Authentication Module\n  description: Production-grade authentication API with email OTP and JWT refresh token rotation\n  version: 1.0.0\nservers:\n  - url: http://localhost:3000/api/v1\n    description: Development server\n  - url: https://api.biye.com/api/v1\n    description: Production server\n\ntags:\n  - name: Authentication\n    description: User authentication and session management endpoints\n\npaths:\n  /auth/register:\n    post:\n      tags:\n        - Authentication\n      summary: Register a new user\n      description: |\n        Initiates user registration by creating an unverified user and sending a 6-digit OTP to the provided email.\n        If the user already exists but is unverified, resends the OTP.\n        Rate limited to 5 requests per 15 minutes per IP.\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              type: object\n              required:\n                - email\n              properties:\n                email:\n                  type: string\n                  format: email\n                  example: user@example.com\n                fullName:\n                  type: string\n                  minLength: 1\n                  example: John Doe\n                phoneNumber:\n                  type: string\n                  pattern: '^\\+?[1-9]\\d{1,14}$'\n                  example: '+1234567890'\n      responses:\n        '201':\n          description: OTP sent successfully\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  success:\n                    type: boolean\n                    example: true\n                  data:\n                    type: object\n                    properties:\n                      success:\n                        type: boolean\n                      message:\n                        type: string\n                        example: 'OTP sent to your email. Please verify to complete registration.'\n        '400':\n          description: Validation error or user already exists\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ErrorResponse'\n        '429':\n          description: Too many requests\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ErrorResponse'\n\n  /auth/verify:\n    post:\n      tags:\n        - Authentication\n      summary: Verify OTP and complete registration\n      description: |\n        Verifies the OTP sent to the user's email and completes registration.\n        Creates a new session and returns access token and refresh token (in HttpOnly cookie).\n        Rate limited to 10 requests per 15 minutes per IP.\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              type: object\n              required:\n                - email\n                - otp\n              properties:\n                email:\n                  type: string\n                  format: email\n                  example: user@example.com\n                otp:\n                  type: string\n                  pattern: '^\\d{6}$'\n                  example: '123456'\n      responses:\n        '200':\n          description: Verification successful\n          headers:\n            Set-Cookie:\n              schema:\n                type: string\n                example: refreshToken=abc123; HttpOnly; Secure; SameSite=Strict; Path=/; Max-Age=604800\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  success:\n                    type: boolean\n                    example: true\n                  data:\n                    $ref: '#/components/schemas/AuthResponse'\n                  message:\n                    type: string\n                    example: 'Verification successful'\n        '400':\n          description: Invalid or expired OTP\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ErrorResponse'\n        '429':\n          description: Too many requests\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ErrorResponse'\n\n  /auth/login:\n    post:\n      tags:\n        - Authentication\n      summary: Login existing user\n      description: |\n        Sends a login OTP to the verified user's email.\n        User must be verified to login.\n        Rate limited to 5 requests per 15 minutes per IP.\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              type: object\n              required:\n                - email\n              properties:\n                email:\n                  type: string\n                  format: email\n                  example: user@example.com\n      responses:\n        '200':\n          description: OTP sent successfully\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  success:\n                    type: boolean\n                    example: true\n                  data:\n                    type: object\n                    properties:\n                      success:\n                        type: boolean\n                      message:\n                        type: string\n                        example: 'OTP sent to your email. Please verify to login.'\n        '400':\n          description: User not found or not verified\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ErrorResponse'\n        '429':\n          description: Too many requests\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ErrorResponse'\n\n  /auth/refresh:\n    post:\n      tags:\n        - Authentication\n      summary: Refresh access token\n      description: |\n        Refreshes the access token using the refresh token from HttpOnly cookie.\n        Implements token rotation - old refresh token is invalidated and new one is issued.\n        Detects and prevents token reuse attacks.\n        Rate limited to 10 requests per 15 minutes per IP.\n      responses:\n        '200':\n          description: Token refreshed successfully\n          headers:\n            Set-Cookie:\n              schema:\n                type: string\n                example: refreshToken=xyz789; HttpOnly; Secure; SameSite=Strict; Path=/; Max-Age=604800\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  success:\n                    type: boolean\n                    example: true\n                  data:\n                    $ref: '#/components/schemas/AuthResponse'\n                  message:\n                    type: string\n                    example: 'Token refreshed successfully'\n        '400':\n          description: Invalid or expired refresh token\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ErrorResponse'\n        '401':\n          description: Token reuse detected or session revoked\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ErrorResponse'\n        '429':\n          description: Too many requests\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ErrorResponse'\n\n  /auth/logout:\n    post:\n      tags:\n        - Authentication\n      summary: Logout user\n      description: |\n        Invalidates the refresh token and revokes the user's session.\n        Clears the refresh token cookie.\n        Requires valid access token.\n      security:\n        - BearerAuth: []\n      responses:\n        '200':\n          description: Logged out successfully\n          headers:\n            Set-Cookie:\n              schema:\n                type: string\n                example: refreshToken=; HttpOnly; Secure; SameSite=Strict; Path=/; Max-Age=0\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  success:\n                    type: boolean\n                    example: true\n                  data:\n                    type: null\n                  message:\n                    type: string\n                    example: 'Logged out successfully'\n        '401':\n          description: Unauthorized\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ErrorResponse'\n\n  /auth/me:\n    get:\n      tags:\n        - Authentication\n      summary: Get current user\n      description: |\n        Returns the authenticated user's information.\n        Requires valid access token.\n        Does not return sensitive fields like OTP hash.\n      security:\n        - BearerAuth: []\n      responses:\n        '200':\n          description: User retrieved successfully\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  success:\n                    type: boolean\n                    example: true\n                  data:\n                    $ref: '#/components/schemas/UserResponse'\n                  message:\n                    type: string\n                    example: 'User retrieved successfully'\n        '401':\n          description: Unauthorized or token expired\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ErrorResponse'\n\ncomponents:\n  securitySchemes:\n    BearerAuth:\n      type: http\n      scheme: bearer\n      bearerFormat: JWT\n      description: JWT access token (valid for 15 minutes)\n\n  schemas:\n    AuthResponse:\n      type: object\n      properties:\n        accessToken:\n          type: string\n          example: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...'\n        user:\n          $ref: '#/components/schemas/UserResponse'\n\n    UserResponse:\n      type: object\n      properties:\n        id:\n          type: string\n          format: uuid\n          example: '123e4567-e89b-12d3-a456-426614174000'\n        email:\n          type: string\n          format: email\n          example: 'user@example.com'\n        fullName:\n          type: string\n          nullable: true\n          example: 'John Doe'\n        phoneNumber:\n          type: string\n          nullable: true\n          example: '+1234567890'\n        isVerified:\n          type: boolean\n          example: true\n        createdAt:\n          type: string\n          format: date-time\n          example: '2025-01-15T10:30:00.000Z'\n\n    ErrorResponse:\n      type: object\n      properties:\n        success:\n          type: boolean\n          example: false\n        error:\n          type: object\n          properties:\n            message:\n              type: string\n              example: 'Invalid OTP'\n            code:\n              type: string\n              example: 'VALIDATION_ERROR'\n            details:\n              type: object\n              nullable: true\n","size_bytes":11336},"openapi-profile.yaml":{"content":"openapi: 3.0.3\ninfo:\n  title: Biye Matrimonial - Profile API\n  description: Profile management API for matrimonial platform with draft/publish workflow\n  version: 1.0.0\n  contact:\n    name: Biye API Support\n\nservers:\n  - url: http://localhost:3000/api/v1\n    description: Development server\n  - url: https://api.biye.com/api/v1\n    description: Production server\n\ntags:\n  - name: Profiles\n    description: Profile management operations\n\npaths:\n  /profiles:\n    post:\n      tags:\n        - Profiles\n      summary: Create new profile\n      description: Create a new profile draft for the authenticated user\n      security:\n        - bearerAuth: []\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              type: object\n              required:\n                - displayName\n              properties:\n                displayName:\n                  type: string\n                  minLength: 2\n                  example: John Doe\n                headline:\n                  type: string\n                  example: Software Engineer from NYC\n                about:\n                  type: string\n                  example: I am a passionate developer...\n      responses:\n        '201':\n          description: Profile created successfully\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ProfileResponse'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '401':\n          $ref: '#/components/responses/Unauthorized'\n        '409':\n          description: Profile already exists\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ErrorResponse'\n\n  /profiles/me:\n    get:\n      tags:\n        - Profiles\n      summary: Get my profile\n      description: Retrieve the authenticated user's profile\n      security:\n        - bearerAuth: []\n      responses:\n        '200':\n          description: Profile retrieved successfully\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ProfileResponse'\n        '404':\n          description: Profile not found\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ErrorResponse'\n        '401':\n          $ref: '#/components/responses/Unauthorized'\n\n  /profiles/{id}:\n    get:\n      tags:\n        - Profiles\n      summary: Get profile by ID\n      description: Retrieve a profile by ID (masked based on viewer permissions)\n      security:\n        - bearerAuth: []\n      parameters:\n        - name: id\n          in: path\n          required: true\n          schema:\n            type: string\n            format: uuid\n      responses:\n        '200':\n          description: Profile retrieved successfully\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/MaskedProfileResponse'\n        '403':\n          description: Profile is not published\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ErrorResponse'\n        '404':\n          $ref: '#/components/responses/NotFound'\n        '401':\n          $ref: '#/components/responses/Unauthorized'\n\n    delete:\n      tags:\n        - Profiles\n      summary: Delete profile\n      description: Soft delete the profile (owner only)\n      security:\n        - bearerAuth: []\n      parameters:\n        - name: id\n          in: path\n          required: true\n          schema:\n            type: string\n            format: uuid\n      responses:\n        '200':\n          description: Profile deleted successfully\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/SuccessResponse'\n        '403':\n          description: Not authorized to delete this profile\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ErrorResponse'\n        '404':\n          $ref: '#/components/responses/NotFound'\n        '401':\n          $ref: '#/components/responses/Unauthorized'\n\n  /profiles/{id}/step:\n    patch:\n      tags:\n        - Profiles\n      summary: Update profile step\n      description: Update a specific step in the profile wizard (owner only)\n      security:\n        - bearerAuth: []\n      parameters:\n        - name: id\n          in: path\n          required: true\n          schema:\n            type: string\n            format: uuid\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              oneOf:\n                - $ref: '#/components/schemas/AboutStepUpdate'\n                - $ref: '#/components/schemas/DemographicsStepUpdate'\n                - $ref: '#/components/schemas/FamilyStepUpdate'\n                - $ref: '#/components/schemas/LifestyleStepUpdate'\n                - $ref: '#/components/schemas/LocationStepUpdate'\n                - $ref: '#/components/schemas/PhotosMetadataStepUpdate'\n                - $ref: '#/components/schemas/PreferencesStepUpdate'\n              discriminator:\n                propertyName: step\n      responses:\n        '200':\n          description: Profile step updated successfully\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ProfileResponse'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '403':\n          description: Not authorized to update this profile\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ErrorResponse'\n        '404':\n          $ref: '#/components/responses/NotFound'\n        '401':\n          $ref: '#/components/responses/Unauthorized'\n\n  /profiles/{id}/publish:\n    post:\n      tags:\n        - Profiles\n      summary: Publish profile\n      description: Publish the profile (makes it visible to others). Requires all mandatory fields.\n      security:\n        - bearerAuth: []\n      parameters:\n        - name: id\n          in: path\n          required: true\n          schema:\n            type: string\n            format: uuid\n      responses:\n        '200':\n          description: Profile published successfully\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ProfileResponse'\n        '400':\n          description: Profile incomplete - missing required fields\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  success:\n                    type: boolean\n                    example: false\n                  error:\n                    type: object\n                    properties:\n                      message:\n                        type: string\n                        example: 'Profile cannot be published. Missing required fields: gender, dob, location'\n        '403':\n          description: Not authorized to publish this profile\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ErrorResponse'\n        '404':\n          $ref: '#/components/responses/NotFound'\n        '401':\n          $ref: '#/components/responses/Unauthorized'\n\n  /profiles/{id}/unpublish:\n    post:\n      tags:\n        - Profiles\n      summary: Unpublish profile\n      description: Unpublish the profile (hides it from others)\n      security:\n        - bearerAuth: []\n      parameters:\n        - name: id\n          in: path\n          required: true\n          schema:\n            type: string\n            format: uuid\n      responses:\n        '200':\n          description: Profile unpublished successfully\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ProfileResponse'\n        '403':\n          description: Not authorized to unpublish this profile\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ErrorResponse'\n        '404':\n          $ref: '#/components/responses/NotFound'\n        '401':\n          $ref: '#/components/responses/Unauthorized'\n\ncomponents:\n  securitySchemes:\n    bearerAuth:\n      type: http\n      scheme: bearer\n      bearerFormat: JWT\n\n  schemas:\n    Profile:\n      type: object\n      properties:\n        id:\n          type: string\n          format: uuid\n        userId:\n          type: string\n          format: uuid\n        displayName:\n          type: string\n        headline:\n          type: string\n        about:\n          type: string\n        gender:\n          type: string\n          enum: [male, female, other]\n        dob:\n          type: string\n          format: date\n        location:\n          type: object\n          properties:\n            city:\n              type: string\n            state:\n              type: string\n            country:\n              type: string\n            coordinates:\n              type: object\n              properties:\n                lat:\n                  type: number\n                lng:\n                  type: number\n        published:\n          type: boolean\n        completeness:\n          type: integer\n          minimum: 0\n          maximum: 100\n        photos:\n          type: array\n          items:\n            $ref: '#/components/schemas/Photo'\n        preferences:\n          $ref: '#/components/schemas/Preference'\n        createdAt:\n          type: string\n          format: date-time\n        updatedAt:\n          type: string\n          format: date-time\n\n    Photo:\n      type: object\n      properties:\n        id:\n          type: string\n          format: uuid\n        profileId:\n          type: string\n          format: uuid\n        objectKey:\n          type: string\n        url:\n          type: string\n          format: uri\n        fileSize:\n          type: integer\n        privacyLevel:\n          type: string\n          enum: [public, private, on_request]\n          default: public\n        moderationStatus:\n          type: string\n          enum: [pending, approved, rejected]\n          default: pending\n        createdAt:\n          type: string\n          format: date-time\n\n    Preference:\n      type: object\n      properties:\n        id:\n          type: string\n          format: uuid\n        profileId:\n          type: string\n          format: uuid\n        basic:\n          type: object\n        lifestyle:\n          type: object\n        education:\n          type: object\n        community:\n          type: object\n        location:\n          type: object\n        createdAt:\n          type: string\n          format: date-time\n        updatedAt:\n          type: string\n          format: date-time\n\n    AboutStepUpdate:\n      type: object\n      required:\n        - step\n        - data\n      properties:\n        step:\n          type: string\n          enum: [about]\n        data:\n          type: object\n          required:\n            - about\n          properties:\n            about:\n              type: string\n              minLength: 50\n            headline:\n              type: string\n              minLength: 10\n\n    DemographicsStepUpdate:\n      type: object\n      required:\n        - step\n        - data\n      properties:\n        step:\n          type: string\n          enum: [demographics]\n        data:\n          type: object\n          required:\n            - gender\n            - dob\n          properties:\n            gender:\n              type: string\n              enum: [male, female, other]\n            dob:\n              type: string\n              format: date\n\n    FamilyStepUpdate:\n      type: object\n      required:\n        - step\n        - data\n      properties:\n        step:\n          type: string\n          enum: [family]\n        data:\n          type: object\n          properties:\n            familyDetails:\n              type: object\n\n    LifestyleStepUpdate:\n      type: object\n      required:\n        - step\n        - data\n      properties:\n        step:\n          type: string\n          enum: [lifestyle]\n        data:\n          type: object\n          properties:\n            lifestyle:\n              type: object\n\n    LocationStepUpdate:\n      type: object\n      required:\n        - step\n        - data\n      properties:\n        step:\n          type: string\n          enum: [location]\n        data:\n          type: object\n          required:\n            - location\n          properties:\n            location:\n              type: object\n              required:\n                - city\n                - state\n                - country\n              properties:\n                city:\n                  type: string\n                state:\n                  type: string\n                country:\n                  type: string\n\n    PhotosMetadataStepUpdate:\n      type: object\n      required:\n        - step\n        - data\n      properties:\n        step:\n          type: string\n          enum: [photos-metadata]\n        data:\n          type: object\n          required:\n            - photos\n          properties:\n            photos:\n              type: array\n              items:\n                type: object\n                required:\n                  - objectKey\n                  - url\n                  - fileSize\n                properties:\n                  objectKey:\n                    type: string\n                  url:\n                    type: string\n                    format: uri\n                  fileSize:\n                    type: integer\n                  privacyLevel:\n                    type: string\n                    enum: [public, private, on_request]\n\n    PreferencesStepUpdate:\n      type: object\n      required:\n        - step\n        - data\n      properties:\n        step:\n          type: string\n          enum: [preferences]\n        data:\n          type: object\n          properties:\n            preferences:\n              type: object\n\n    ProfileResponse:\n      type: object\n      properties:\n        success:\n          type: boolean\n          example: true\n        data:\n          $ref: '#/components/schemas/Profile'\n        message:\n          type: string\n\n    MaskedProfileResponse:\n      type: object\n      properties:\n        success:\n          type: boolean\n          example: true\n        data:\n          type: object\n          properties:\n            id:\n              type: string\n              format: uuid\n            displayName:\n              type: string\n            headline:\n              type: string\n            about:\n              type: string\n              description: May be truncated for non-premium users\n            gender:\n              type: string\n            age:\n              type: integer\n            location:\n              type: object\n              description: Coordinates removed for privacy\n            completeness:\n              type: integer\n            photos:\n              type: array\n              items:\n                $ref: '#/components/schemas/Photo'\n              description: Only public photos shown to non-premium users\n\n    SuccessResponse:\n      type: object\n      properties:\n        success:\n          type: boolean\n          example: true\n        message:\n          type: string\n\n    ErrorResponse:\n      type: object\n      properties:\n        success:\n          type: boolean\n          example: false\n        error:\n          type: object\n          properties:\n            message:\n              type: string\n            code:\n              type: string\n            details:\n              type: object\n\n  responses:\n    BadRequest:\n      description: Bad request - validation error\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/ErrorResponse'\n\n    Unauthorized:\n      description: Unauthorized - invalid or missing token\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/ErrorResponse'\n\n    NotFound:\n      description: Resource not found\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/ErrorResponse'\n","size_bytes":16204},"src/modules/profile/completeness.service.ts":{"content":"import { ProfileData } from './profile.types.js';\nimport { logger } from '../../utils/logger.js';\n\ninterface CompletenessWeights {\n  displayName: number;\n  headline: number;\n  about: number;\n  gender: number;\n  dob: number;\n  location: number;\n  photos: number;\n  preferences: number;\n}\n\nconst WEIGHTS: CompletenessWeights = {\n  displayName: 10,\n  headline: 10,\n  about: 15,\n  gender: 10,\n  dob: 10,\n  location: 15,\n  photos: 20,\n  preferences: 10,\n};\n\nexport class CompletenessService {\n  calculateCompleteness(profile: ProfileData): number {\n    let score = 0;\n\n    if (profile.displayName && profile.displayName.length >= 2) {\n      score += WEIGHTS.displayName;\n    }\n\n    if (profile.headline && profile.headline.length >= 10) {\n      score += WEIGHTS.headline;\n    }\n\n    if (profile.about && profile.about.length >= 50) {\n      score += WEIGHTS.about;\n    }\n\n    if (profile.gender) {\n      score += WEIGHTS.gender;\n    }\n\n    if (profile.dob) {\n      score += WEIGHTS.dob;\n    }\n\n    if (profile.location && this.isValidLocation(profile.location)) {\n      score += WEIGHTS.location;\n    }\n\n    if (profile.photos && profile.photos.length > 0) {\n      score += WEIGHTS.photos;\n    }\n\n    if (profile.preferences && this.isValidPreferences(profile.preferences)) {\n      score += WEIGHTS.preferences;\n    }\n\n    logger.debug('Profile completeness calculated', {\n      profileId: profile.id,\n      score,\n    });\n\n    return Math.min(score, 100);\n  }\n\n  getIncompleteSections(profile: ProfileData): string[] {\n    const incomplete: string[] = [];\n\n    if (!profile.displayName || profile.displayName.length < 2) {\n      incomplete.push('displayName');\n    }\n\n    if (!profile.headline || profile.headline.length < 10) {\n      incomplete.push('headline');\n    }\n\n    if (!profile.about || profile.about.length < 50) {\n      incomplete.push('about');\n    }\n\n    if (!profile.gender) {\n      incomplete.push('gender');\n    }\n\n    if (!profile.dob) {\n      incomplete.push('dob');\n    }\n\n    if (!profile.location || !this.isValidLocation(profile.location)) {\n      incomplete.push('location');\n    }\n\n    if (!profile.photos || profile.photos.length === 0) {\n      incomplete.push('photos');\n    }\n\n    if (!profile.preferences || !this.isValidPreferences(profile.preferences)) {\n      incomplete.push('preferences');\n    }\n\n    return incomplete;\n  }\n\n  canPublish(profile: ProfileData): { canPublish: boolean; missingFields: string[] } {\n    const required = ['displayName', 'gender', 'dob', 'location', 'about', 'headline'];\n    const missingFields: string[] = [];\n\n    if (!profile.displayName || profile.displayName.length < 2) {\n      missingFields.push('displayName');\n    }\n\n    if (!profile.gender) {\n      missingFields.push('gender');\n    }\n\n    if (!profile.dob) {\n      missingFields.push('dob');\n    }\n\n    if (!profile.location || !this.isValidLocation(profile.location)) {\n      missingFields.push('location');\n    }\n\n    if (!profile.about || profile.about.length < 50) {\n      missingFields.push('about');\n    }\n\n    if (!profile.headline || profile.headline.length < 10) {\n      missingFields.push('headline');\n    }\n\n    if (!profile.photos || profile.photos.length === 0) {\n      missingFields.push('photos (at least 1 required)');\n    }\n\n    return {\n      canPublish: missingFields.length === 0,\n      missingFields,\n    };\n  }\n\n  private isValidLocation(location: any): boolean {\n    return (\n      location &&\n      typeof location === 'object' &&\n      location.city &&\n      location.state &&\n      location.country\n    );\n  }\n\n  private isValidPreferences(preferences: any): boolean {\n    return preferences && typeof preferences === 'object' && Object.keys(preferences).length > 0;\n  }\n}\n\nexport const completenessService = new CompletenessService();\n","size_bytes":3781},"src/modules/auth/auth.controller.ts":{"content":"import { Request, Response, NextFunction } from 'express';\nimport { authService } from './auth.service.js';\nimport { RegisterDTO, VerifyOTPDTO, LoginDTO } from './auth.dto.js';\nimport { SessionInfo } from './auth.types.js';\nimport { sendSuccess } from '../../utils/response.js';\nimport { logger } from '../../utils/logger.js';\n\nexport class AuthController {\n  async register(req: Request, res: Response, next: NextFunction) {\n    try {\n      const dto: RegisterDTO = req.body;\n\n      const result = await authService.register(dto);\n\n      return sendSuccess(res, result, result.message, 201);\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async verify(req: Request, res: Response, next: NextFunction) {\n    try {\n      const dto: VerifyOTPDTO = req.body;\n\n      const sessionInfo: SessionInfo = {\n        deviceId: req.headers['x-device-id'] as string,\n        ip: (req.headers['x-forwarded-for'] as string) || req.ip,\n        userAgent: req.headers['user-agent'],\n      };\n\n      const result = await authService.verify(dto, sessionInfo);\n\n      res.cookie('refreshToken', result.refreshToken, {\n        httpOnly: true,\n        secure: process.env.NODE_ENV === 'production',\n        sameSite: 'strict',\n        maxAge: 7 * 24 * 60 * 60 * 1000,\n        path: '/',\n      });\n\n      return sendSuccess(res, result, 'Verification successful', 200);\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async login(req: Request, res: Response, next: NextFunction) {\n    try {\n      const dto: LoginDTO = req.body;\n\n      const result = await authService.login(dto);\n\n      return sendSuccess(res, result, 'OTP sent to your email. Please verify to login.', 200);\n    } catch (error) {\n      next(error);\n    }\n  }\n\n\n  async refresh(req: Request, res: Response, next: NextFunction) {\n    try {\n      const refreshToken = req.cookies.refreshToken;\n\n      if (!refreshToken) {\n        throw new Error('Refresh token not found');\n      }\n\n      const sessionInfo: SessionInfo = {\n        deviceId: req.headers['x-device-id'] as string,\n        ip: (req.headers['x-forwarded-for'] as string) || req.ip,\n        userAgent: req.headers['user-agent'],\n      };\n\n      const result = await authService.refresh(refreshToken, sessionInfo);\n\n      res.cookie('refreshToken', result.refreshToken, {\n        httpOnly: true,\n        secure: process.env.NODE_ENV === 'production',\n        sameSite: 'strict',\n        maxAge: 7 * 24 * 60 * 60 * 1000,\n        path: '/',\n      });\n\n      return sendSuccess(res, result, 'Token refreshed successfully', 200);\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async logout(req: Request, res: Response, next: NextFunction) {\n    try {\n      const refreshToken = req.cookies.refreshToken;\n      const sessionId = (req as any).sessionId;\n\n      if (!refreshToken || !sessionId) {\n        throw new Error('Invalid logout request');\n      }\n\n      await authService.logout(refreshToken, sessionId);\n\n      res.clearCookie('refreshToken', {\n        httpOnly: true,\n        secure: process.env.NODE_ENV === 'production',\n        sameSite: 'strict',\n        path: '/',\n      });\n\n      return sendSuccess(res, null, 'Logged out successfully', 200);\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async me(req: Request, res: Response, next: NextFunction) {\n    try {\n      const userId = (req as any).userId;\n\n      if (!userId) {\n        throw new Error('Unauthorized');\n      }\n\n      const user = await authService.getMe(userId);\n\n      return sendSuccess(res, user, 'User retrieved successfully', 200);\n    } catch (error) {\n      next(error);\n    }\n  }\n}\n\nexport const authController = new AuthController();\n","size_bytes":3649},"jest.config.js":{"content":"export default {\n  preset: 'ts-jest/presets/default-esm',\n  testEnvironment: 'node',\n  extensionsToTreatAsEsm: ['.ts'],\n  moduleNameMapper: {\n    '^(\\\\.{1,2}/.*)\\\\.js$': '$1',\n  },\n  transform: {\n    '^.+\\\\.tsx?$': [\n      'ts-jest',\n      {\n        useESM: true,\n      },\n    ],\n  },\n  testMatch: ['**/__tests__/**/*.test.ts'],\n  collectCoverageFrom: [\n    'src/**/*.ts',\n    '!src/**/*.d.ts',\n    '!src/server.ts',\n  ],\n  coverageDirectory: 'coverage',\n  coverageReporters: ['text', 'lcov', 'html'],\n  verbose: true,\n};\n","size_bytes":522},"src/server.ts":{"content":"import { app } from './index.js';\nimport { env } from './config/env.js';\nimport { logger } from './utils/logger.js';\n\nconst PORT = env.PORT;\n\nconst server = app.listen(PORT, () => {\n  logger.info(`ðŸš€ Server running in ${env.NODE_ENV} mode on port ${PORT}`);\n  logger.info(`ðŸ“¡ Health check: http://localhost:${PORT}/api/health`);\n});\n\nprocess.on('SIGTERM', () => {\n  logger.info('SIGTERM signal received: closing HTTP server');\n  server.close(() => {\n    logger.info('HTTP server closed');\n    process.exit(0);\n  });\n});\n\nprocess.on('SIGINT', () => {\n  logger.info('SIGINT signal received: closing HTTP server');\n  server.close(() => {\n    logger.info('HTTP server closed');\n    process.exit(0);\n  });\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n  logger.error('Unhandled Rejection at:', { promise, reason });\n});\n\nprocess.on('uncaughtException', (error) => {\n  logger.error('Uncaught Exception:', { error: error.message, stack: error.stack });\n  process.exit(1);\n});\n","size_bytes":988},"src/index.ts":{"content":"import express, { Request, Response, NextFunction } from 'express';\nimport cookieParser from 'cookie-parser';\nimport { helmetMiddleware } from './middleware/helmet.js';\nimport { corsMiddleware } from './middleware/cors.js';\nimport { rateLimiter } from './middleware/rateLimit.js';\nimport { requestIdMiddleware } from './middleware/requestId.js';\nimport { errorHandler } from './middleware/errorHandler.js';\nimport { logRequest } from './utils/logger.js';\nimport healthRoute from './routes/health.route.js';\nimport authRoutes from './modules/auth/auth.routes.js';\nimport profileRoutes from './modules/profile/profile.routes.js';\n\nexport function createApp() {\n  const app = express();\n\n  app.use(requestIdMiddleware);\n\n  app.use((req: Request, res: Response, next: NextFunction) => {\n    const start = Date.now();\n\n    res.on('finish', () => {\n      const duration = Date.now() - start;\n      logRequest(req.requestId, req.method, req.path, res.statusCode, duration);\n    });\n\n    next();\n  });\n\n  app.use(helmetMiddleware);\n  app.use(corsMiddleware);\n  app.use(rateLimiter);\n\n  app.use(express.json({ limit: '10mb' }));\n  app.use(express.urlencoded({ extended: true, limit: '10mb' }));\n  app.use(cookieParser());\n\n  app.use('/api/health', healthRoute);\n  app.use('/api/v1/auth', authRoutes);\n  app.use('/api/v1/profiles', profileRoutes);\n\n  app.use((_req: Request, res: Response) => {\n    res.status(404).json({\n      success: false,\n      error: {\n        message: 'Route not found',\n        code: 'NOT_FOUND',\n      },\n    });\n  });\n\n  app.use(errorHandler);\n\n  return app;\n}\n\nexport const app = createApp();\n","size_bytes":1611},"src/config/env.ts":{"content":"import { z } from 'zod';\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nconst envSchema = z.object({\n  DATABASE_URL: z.string().min(1, 'postgresql://postgres:postgres@localhost:5432/biye_db'),\n  REDIS_URL: z.string().min(1, 'redis://127.0.0.1:6379'),\n  JWT_SECRET: z.string().min(32, '58038c80d42a960fe3618326f7ac0273'),\n  JWT_REFRESH_SECRET: z.string().min(32, '6411c27a28bc57b0841348b5d21adb3c'),\n  JWT_ACCESS_EXPIRY: z.string().default('15m'),\n  JWT_REFRESH_EXPIRY: z.string().default('7d'),\n  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),\n  PORT: z.string().default('3000').transform(Number).refine((val) => !Number.isNaN(val), {\n    message: 'PORT must be a valid number',\n  }),\n  LOG_LEVEL: z.enum(['error', 'warn', 'info', 'http', 'verbose', 'debug', 'silly']).default('info'),\n  ALLOWED_ORIGINS: z.string().transform((val) => val.split(',').map((origin) => origin.trim())),\n});\n\nexport type Env = z.infer<typeof envSchema>;\n\nfunction validateEnv(): Env {\n  try {\n    return envSchema.parse(process.env);\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      const missingVars = error.errors.map((err) => `${err.path.join('.')}: ${err.message}`).join('\\n');\n      throw new Error(`Environment validation failed:\\n${missingVars}`);\n    }\n    throw error;\n  }\n}\n\nexport const env = validateEnv();\n","size_bytes":1348},"src/middleware/errorHandler.ts":{"content":"import { Request, Response, NextFunction } from 'express';\nimport { logger } from '../utils/logger.js';\nimport { sendError } from '../utils/response.js';\nimport { ZodError } from 'zod';\n\nexport function errorHandler(\n  err: Error,\n  req: Request,\n  res: Response,\n  _next: NextFunction\n): void {\n  logger.error('Error occurred', {\n    requestId: req.requestId,\n    error: err.message,\n    stack: err.stack,\n    path: req.path,\n    method: req.method,\n  });\n\n  if (err instanceof ZodError) {\n    sendError(\n      res,\n      'Validation failed',\n      400,\n      'VALIDATION_ERROR',\n      err.errors\n    );\n    return;\n  }\n\n  if (err.name === 'UnauthorizedError') {\n    sendError(res, 'Unauthorized', 401, 'UNAUTHORIZED');\n    return;\n  }\n\n  if (err.message === 'Not allowed by CORS') {\n    sendError(res, 'CORS policy violation', 403, 'CORS_ERROR');\n    return;\n  }\n\n  sendError(\n    res,\n    process.env.NODE_ENV === 'production' \n      ? 'Internal server error' \n      : err.message,\n    500,\n    'INTERNAL_SERVER_ERROR'\n  );\n}\n","size_bytes":1029},"AUTH_MODULE_README.md":{"content":"# Authentication Module - Implementation Complete\n\n## Overview\n\nThis authentication module implements a production-grade email OTP-based authentication system with JWT access tokens and rotating refresh tokens.\n\n## Features Implemented\n\n- âœ… Email-based OTP registration and login\n- âœ… Bcrypt-hashed OTP storage with expiry (5 minutes)\n- âœ… JWT access tokens (15 minute expiry)\n- âœ… Rotating refresh tokens stored in Redis\n- âœ… HttpOnly, Secure cookies for refresh tokens\n- âœ… Session tracking (device ID, IP, user agent)\n- âœ… Token reuse detection\n- âœ… Rate limiting (OTP: 3 per 15 min per email, 5 per IP)\n- âœ… Full Zod validation on all endpoints\n- âœ… Comprehensive unit tests\n- âœ… OpenAPI documentation\n\n## File Structure\n\n```\nbackend/\nâ”œâ”€â”€ prisma/\nâ”‚   â””â”€â”€ schema.prisma              # Updated with User and Session models\nâ”œâ”€â”€ src/\nâ”‚   â”œâ”€â”€ config/\nâ”‚   â”‚   â”œâ”€â”€ env.ts                 # Updated with new JWT env variables\nâ”‚   â”‚   â””â”€â”€ redis.ts               # NEW - Redis client wrapper\nâ”‚   â”œâ”€â”€ modules/\nâ”‚   â”‚   â””â”€â”€ auth/\nâ”‚   â”‚       â”œâ”€â”€ auth.types.ts      # NEW - Type definitions\nâ”‚   â”‚       â”œâ”€â”€ auth.dto.ts        # NEW - Zod validation schemas\nâ”‚   â”‚       â”œâ”€â”€ email.service.ts   # NEW - Email OTP service (stub)\nâ”‚   â”‚       â”œâ”€â”€ token.service.ts   # NEW - JWT & refresh token management\nâ”‚   â”‚       â”œâ”€â”€ session.service.ts # NEW - Session tracking service\nâ”‚   â”‚       â”œâ”€â”€ auth.service.ts    # NEW - Core authentication logic\nâ”‚   â”‚       â”œâ”€â”€ auth.controller.ts # NEW - Request handlers\nâ”‚   â”‚       â”œâ”€â”€ auth.routes.ts     # NEW - Route definitions\nâ”‚   â”‚       â””â”€â”€ auth.test.ts       # NEW - Unit tests\nâ”‚   â”œâ”€â”€ middleware/\nâ”‚   â”‚   â””â”€â”€ authMiddleware.ts      # UPDATED - JWT validation with session check\nâ”‚   â””â”€â”€ index.ts                   # UPDATED - Register auth routes\nâ”œâ”€â”€ .env.example                   # UPDATED - New environment variables\nâ””â”€â”€ openapi-auth.yaml              # NEW - Complete API documentation\n```\n\n## Database Schema Changes\n\n### User Model (Updated)\n```prisma\nmodel User {\n  id          String    @id @default(uuid())\n  email       String    @unique\n  fullName    String?\n  phoneNumber String?\n  isVerified  Boolean   @default(false)\n  otpHash     String?\n  otpExpiry   DateTime?\n  sessions    Session[]\n  createdAt   DateTime  @default(now())\n  updatedAt   DateTime  @updatedAt\n}\n```\n\n### Session Model (New)\n```prisma\nmodel Session {\n  id         String   @id @default(uuid())\n  userId     String\n  deviceId   String?\n  ip         String?\n  userAgent  String?\n  revoked    Boolean  @default(false)\n  createdAt  DateTime @default(now())\n  lastSeenAt DateTime @updatedAt\n  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n}\n```\n\n## API Endpoints\n\nAll endpoints are under `/api/v1/auth/`\n\n### 1. POST /register\n**Body:**\n```json\n{\n  \"email\": \"user@example.com\",\n  \"fullName\": \"John Doe\",\n  \"phoneNumber\": \"+1234567890\"\n}\n```\n\n**Response:** (201)\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"success\": true,\n    \"message\": \"OTP sent to your email. Please verify to complete registration.\"\n  }\n}\n```\n\n**Features:**\n- Creates new unverified user or resends OTP for existing unverified users\n- Generates 6-digit OTP\n- Hashes OTP with bcrypt (never stores plain OTP)\n- Sets 5-minute expiry\n- Rate limited: 3 OTP per 15 min per email, 5 requests per 15 min per IP\n\n---\n\n### 2. POST /verify\n**Body:**\n```json\n{\n  \"email\": \"user@example.com\",\n  \"otp\": \"123456\"\n}\n```\n\n**Response:** (200)\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"accessToken\": \"eyJhbGciOiJIUzI1NiIs...\",\n    \"user\": {\n      \"id\": \"uuid\",\n      \"email\": \"user@example.com\",\n      \"fullName\": \"John Doe\",\n      \"phoneNumber\": \"+1234567890\",\n      \"isVerified\": true,\n      \"createdAt\": \"2025-11-16T...\"\n    }\n  }\n}\n```\n\n**Features:**\n- Validates OTP against hashed value\n- Checks expiry\n- Marks user as verified\n- Creates new session with device/IP/UA tracking\n- Generates JWT access token (15m expiry)\n- Generates UUID refresh token, stores hashed in Redis (7d expiry)\n- Sets refresh token in HttpOnly, Secure, SameSite=Strict cookie\n- Sends welcome email\n- Rate limited: 10 requests per 15 min per IP\n\n---\n\n### 3. POST /login\n**Body:**\n```json\n{\n  \"email\": \"user@example.com\"\n}\n```\n\n**Response:** (200)\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"success\": true,\n    \"message\": \"OTP sent to your email. Please verify to login.\"\n  }\n}\n```\n\n**Features:**\n- Only allows verified users to login\n- Generates and sends login OTP\n- Same rate limiting as register\n- After OTP is sent, user verifies using /verify endpoint\n\n---\n\n### 4. POST /refresh\n**Headers:**\n```\nCookie: refreshToken=<token>\n```\n\n**Response:** (200)\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"accessToken\": \"eyJhbGciOiJIUzI1NiIs...\",\n    \"user\": { ... }\n  }\n}\n```\n\n**Features:**\n- Reads refresh token from HttpOnly cookie\n- Verifies token exists in Redis\n- Checks session is not revoked\n- **Rotates token:** deletes old, creates new\n- Returns new access token\n- Sets new refresh token cookie\n- Updates session lastSeenAt\n- **Token reuse detection:** if old token is used again, invalidates ALL user tokens\n- Rate limited: 10 requests per 15 min per IP\n\n---\n\n### 5. POST /logout\n**Headers:**\n```\nAuthorization: Bearer <access_token>\nCookie: refreshToken=<token>\n```\n\n**Response:** (200)\n```json\n{\n  \"success\": true,\n  \"data\": null,\n  \"message\": \"Logged out successfully\"\n}\n```\n\n**Features:**\n- Requires valid access token\n- Invalidates refresh token in Redis\n- Revokes session in database\n- Clears refresh token cookie\n\n---\n\n### 6. GET /me\n**Headers:**\n```\nAuthorization: Bearer <access_token>\n```\n\n**Response:** (200)\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"id\": \"uuid\",\n    \"email\": \"user@example.com\",\n    \"fullName\": \"John Doe\",\n    \"phoneNumber\": \"+1234567890\",\n    \"isVerified\": true,\n    \"createdAt\": \"2025-11-16T...\"\n  }\n}\n```\n\n**Features:**\n- Requires valid access token\n- Returns user data (no sensitive fields like otpHash)\n- Updates session activity\n\n---\n\n## Environment Variables\n\nAdd these to your `.env` file:\n\n```env\n# Existing\nDATABASE_URL=postgresql://...\nREDIS_URL=redis://localhost:6379\n\n# New JWT variables\nJWT_SECRET=your-super-secret-jwt-key-min-32-chars\nJWT_REFRESH_SECRET=your-super-secret-refresh-key-min-32-chars\nJWT_ACCESS_EXPIRY=15m\nJWT_REFRESH_EXPIRY=7d\n\n# Existing\nNODE_ENV=development\nPORT=3000\nLOG_LEVEL=info\nALLOWED_ORIGINS=http://localhost:3000\n```\n\n## Security Features\n\n1. **OTP Security:**\n   - Never stores plain OTP (bcrypt hashed)\n   - 5-minute expiry\n   - Rate limited (3 per 15 min per email)\n   - Not logged in production\n\n2. **JWT Security:**\n   - Access tokens: 15-minute expiry\n   - Refresh tokens: UUID-based, stored hashed in Redis\n   - Separate secrets for access and refresh tokens\n   - Token rotation on refresh\n\n3. **Cookie Security:**\n   - HttpOnly (prevents XSS)\n   - Secure (HTTPS only in production)\n   - SameSite=Strict (prevents CSRF)\n   - Path=/ (scoped to auth endpoints)\n\n4. **Session Security:**\n   - Tracks device ID, IP, user agent\n   - Session validation on every protected request\n   - Can be revoked individually or all at once\n   - Updates lastSeenAt for activity tracking\n\n5. **Token Reuse Detection:**\n   - If a used refresh token is presented again, all user tokens are invalidated\n   - Protects against token theft\n\n## Setup Instructions\n\n### 1. Install Dependencies\n```bash\nnpm install\n```\n\n### 2. Update Environment Variables\n```bash\ncp .env.example .env\n# Edit .env with your values\n```\n\n### 3. Generate Prisma Client\n```bash\nnpx prisma generate\n```\n\n### 4. Run Database Migration\n```bash\nnpx prisma migrate dev --name add_auth_module\n```\n\n### 5. Start Redis\n```bash\n# Make sure Redis is running locally\nredis-server\n```\n\n### 6. Start Development Server\n```bash\nnpm run dev\n```\n\n## Testing\n\nRun the test suite:\n```bash\nnpm test\n```\n\nRun tests with coverage:\n```bash\nnpm run test:coverage\n```\n\n## API Documentation\n\nComplete OpenAPI 3.0 specification is available in `openapi-auth.yaml`.\n\nYou can view it using:\n- Swagger UI\n- Postman (import the YAML file)\n- Any OpenAPI viewer\n\n## Authentication Flow\n\n### Registration Flow:\n1. Client calls `POST /register` with email\n2. Server creates unverified user, sends OTP via email\n3. Client calls `POST /verify` with email + OTP\n4. Server validates OTP, creates session, returns access token + sets refresh cookie\n5. Client stores access token, uses it for authenticated requests\n\n### Login Flow:\n1. Client calls `POST /login` with email\n2. Server sends OTP to verified user's email\n3. Client calls `POST /verify` with email + OTP (same as registration)\n4. Server validates OTP, creates new session, returns tokens\n\n### Token Refresh Flow:\n1. When access token expires (after 15 min), client calls `POST /refresh`\n2. Server validates refresh token from cookie, rotates it\n3. Server returns new access token, sets new refresh cookie\n4. Client uses new access token\n\n### Logout Flow:\n1. Client calls `POST /logout` with access token + refresh cookie\n2. Server invalidates refresh token, revokes session, clears cookie\n3. Client discards access token\n\n## Notes\n\n- Email service is currently a stub (logs OTP instead of sending email)\n- In development mode, OTP is logged for testing\n- All endpoints return standardized response format\n- All errors are handled by centralized error handler\n- Rate limiting is enforced at both IP and email level\n- Session tracking enables features like \"active sessions\" view\n\n## Next Steps\n\nTo integrate email sending:\n1. Update `src/modules/auth/email.service.ts`\n2. Add email provider credentials to `.env`\n3. Install email library (nodemailer, sendgrid, etc.)\n4. Implement actual email sending logic\n\nTo add more features:\n1. Password reset flow\n2. Email change flow\n3. Two-factor authentication\n4. Social login (OAuth)\n5. Active sessions management endpoint\n6. Device management (revoke specific sessions)\n","size_bytes":10058},"src/modules/profile/profile.dto.ts":{"content":"import { z } from 'zod';\n\nexport const CreateProfileSchema = z.object({\n  displayName: z.string().min(2, 'Display name must be at least 2 characters'),\n  headline: z.string().optional(),\n  about: z.string().optional(),\n});\n\nexport const UpdateAboutStepSchema = z.object({\n  about: z.string().min(50, 'About section must be at least 50 characters'),\n  headline: z.string().min(10, 'Headline must be at least 10 characters').optional(),\n});\n\nexport const UpdateDemographicsStepSchema = z.object({\n  gender: z.enum(['male', 'female', 'other']),\n  dob: z.string().refine((date) => {\n    const birthDate = new Date(date);\n    const age = new Date().getFullYear() - birthDate.getFullYear();\n    return age >= 18 && age <= 100;\n  }, 'Age must be between 18 and 100'),\n});\n\nexport const UpdateFamilyStepSchema = z.object({\n  familyDetails: z.object({\n    fatherName: z.string().optional(),\n    motherName: z.string().optional(),\n    siblings: z.number().int().min(0).optional(),\n    familyType: z.enum(['nuclear', 'joint']).optional(),\n    familyValues: z.enum(['traditional', 'moderate', 'liberal']).optional(),\n  }),\n});\n\nexport const UpdateLifestyleStepSchema = z.object({\n  lifestyle: z.object({\n    diet: z.enum(['vegetarian', 'non-vegetarian', 'vegan', 'other']).optional(),\n    drinking: z.enum(['never', 'occasionally', 'socially', 'regularly']).optional(),\n    smoking: z.enum(['never', 'occasionally', 'regularly']).optional(),\n    maritalStatus: z.enum(['never_married', 'divorced', 'widowed', 'separated']).optional(),\n  }),\n});\n\nexport const UpdateLocationStepSchema = z.object({\n  location: z.object({\n    city: z.string().min(2),\n    state: z.string().min(2),\n    country: z.string().min(2),\n    coordinates: z\n      .object({\n        lat: z.number(),\n        lng: z.number(),\n      })\n      .optional(),\n  }),\n});\n\nexport const UpdatePhotosMetadataStepSchema = z.object({\n  photos: z.array(\n    z.object({\n      objectKey: z.string(),\n      url: z.string().url(),\n      fileSize: z.number().int().positive(),\n      privacyLevel: z.enum(['public', 'private', 'on_request']).default('public'),\n    })\n  ),\n});\n\nexport const UpdatePreferencesStepSchema = z.object({\n  preferences: z.object({\n    basic: z\n      .object({\n        ageRange: z.object({\n          min: z.number().int().min(18),\n          max: z.number().int().max(100),\n        }),\n        heightRange: z\n          .object({\n            min: z.number(),\n            max: z.number(),\n          })\n          .optional(),\n        maritalStatus: z.array(z.string()).optional(),\n      })\n      .optional(),\n    lifestyle: z\n      .object({\n        diet: z.array(z.string()).optional(),\n        drinking: z.array(z.string()).optional(),\n        smoking: z.array(z.string()).optional(),\n      })\n      .optional(),\n    education: z\n      .object({\n        minEducation: z.string().optional(),\n        fieldOfStudy: z.array(z.string()).optional(),\n      })\n      .optional(),\n    community: z\n      .object({\n        religion: z.array(z.string()).optional(),\n        caste: z.array(z.string()).optional(),\n        motherTongue: z.array(z.string()).optional(),\n      })\n      .optional(),\n    location: z\n      .object({\n        cities: z.array(z.string()).optional(),\n        countries: z.array(z.string()).optional(),\n        willingToRelocate: z.boolean().optional(),\n      })\n      .optional(),\n  }),\n});\n\nexport const StepUpdateSchema = z.discriminatedUnion('step', [\n  z.object({ step: z.literal('about'), data: UpdateAboutStepSchema }),\n  z.object({ step: z.literal('demographics'), data: UpdateDemographicsStepSchema }),\n  z.object({ step: z.literal('family'), data: UpdateFamilyStepSchema }),\n  z.object({ step: z.literal('lifestyle'), data: UpdateLifestyleStepSchema }),\n  z.object({ step: z.literal('location'), data: UpdateLocationStepSchema }),\n  z.object({ step: z.literal('photos-metadata'), data: UpdatePhotosMetadataStepSchema }),\n  z.object({ step: z.literal('preferences'), data: UpdatePreferencesStepSchema }),\n]);\n\nexport type CreateProfileDTO = z.infer<typeof CreateProfileSchema>;\nexport type UpdateAboutStepDTO = z.infer<typeof UpdateAboutStepSchema>;\nexport type UpdateDemographicsStepDTO = z.infer<typeof UpdateDemographicsStepSchema>;\nexport type UpdateFamilyStepDTO = z.infer<typeof UpdateFamilyStepSchema>;\nexport type UpdateLifestyleStepDTO = z.infer<typeof UpdateLifestyleStepSchema>;\nexport type UpdateLocationStepDTO = z.infer<typeof UpdateLocationStepSchema>;\nexport type UpdatePhotosMetadataStepDTO = z.infer<typeof UpdatePhotosMetadataStepSchema>;\nexport type UpdatePreferencesStepDTO = z.infer<typeof UpdatePreferencesStepSchema>;\nexport type StepUpdateDTO = z.infer<typeof StepUpdateSchema>;\n","size_bytes":4689},"src/modules/auth/auth.test.ts":{"content":"import request from 'supertest';\nimport { createApp } from '../../index.js';\nimport { PrismaClient } from '@prisma/client';\nimport { redis } from '../../config/redis.js';\n\nconst app = createApp();\nconst prisma = new PrismaClient();\n\ndescribe('Auth Module', () => {\n  const testEmail = 'test@example.com';\n  const testFullName = 'Test User';\n\n  beforeAll(async () => {\n    await prisma.user.deleteMany({\n      where: { email: testEmail },\n    });\n  });\n\n  afterAll(async () => {\n    await prisma.user.deleteMany({\n      where: { email: testEmail },\n    });\n    await prisma.$disconnect();\n    await redis.quit();\n  });\n\n  describe('POST /api/v1/auth/register', () => {\n    it('should register a new user and send OTP', async () => {\n      const response = await request(app)\n        .post('/api/v1/auth/register')\n        .send({\n          email: testEmail,\n          fullName: testFullName,\n        })\n        .expect(201);\n\n      expect(response.body).toMatchObject({\n        success: true,\n        data: {\n          success: true,\n        },\n      });\n\n      const user = await prisma.user.findUnique({\n        where: { email: testEmail },\n      });\n\n      expect(user).toBeDefined();\n      expect(user?.email).toBe(testEmail);\n      expect(user?.fullName).toBe(testFullName);\n      expect(user?.isVerified).toBe(false);\n      expect(user?.otpHash).toBeDefined();\n      expect(user?.otpExpiry).toBeDefined();\n    });\n\n    it('should resend OTP for unverified user', async () => {\n      const response = await request(app)\n        .post('/api/v1/auth/register')\n        .send({\n          email: testEmail,\n          fullName: testFullName,\n        })\n        .expect(201);\n\n      expect(response.body.success).toBe(true);\n    });\n\n    it('should reject invalid email', async () => {\n      const response = await request(app)\n        .post('/api/v1/auth/register')\n        .send({\n          email: 'invalid-email',\n          fullName: testFullName,\n        })\n        .expect(400);\n\n      expect(response.body.success).toBe(false);\n    });\n  });\n\n  describe('POST /api/v1/auth/verify', () => {\n    it('should reject invalid OTP', async () => {\n      const response = await request(app)\n        .post('/api/v1/auth/verify')\n        .send({\n          email: testEmail,\n          otp: '000000',\n        })\n        .expect(400);\n\n      expect(response.body.success).toBe(false);\n    });\n\n    it('should reject expired OTP', async () => {\n      await prisma.user.update({\n        where: { email: testEmail },\n        data: {\n          otpExpiry: new Date(Date.now() - 10 * 60 * 1000),\n        },\n      });\n\n      const response = await request(app)\n        .post('/api/v1/auth/verify')\n        .send({\n          email: testEmail,\n          otp: '123456',\n        })\n        .expect(400);\n\n      expect(response.body.success).toBe(false);\n    });\n  });\n\n  describe('POST /api/v1/auth/login', () => {\n    it('should reject login for non-existent user', async () => {\n      const response = await request(app)\n        .post('/api/v1/auth/login')\n        .send({\n          email: 'nonexistent@example.com',\n        })\n        .expect(400);\n\n      expect(response.body.success).toBe(false);\n    });\n\n    it('should reject login for unverified user', async () => {\n      const response = await request(app)\n        .post('/api/v1/auth/login')\n        .send({\n          email: testEmail,\n        })\n        .expect(400);\n\n      expect(response.body.success).toBe(false);\n    });\n  });\n\n  describe('POST /api/v1/auth/refresh', () => {\n    it('should reject refresh with no token', async () => {\n      const response = await request(app).post('/api/v1/auth/refresh').expect(400);\n\n      expect(response.body.success).toBe(false);\n    });\n\n    it('should reject refresh with invalid token', async () => {\n      const response = await request(app)\n        .post('/api/v1/auth/refresh')\n        .set('Cookie', ['refreshToken=invalid-token'])\n        .expect(400);\n\n      expect(response.body.success).toBe(false);\n    });\n  });\n\n  describe('GET /api/v1/auth/me', () => {\n    it('should reject unauthorized request', async () => {\n      const response = await request(app).get('/api/v1/auth/me').expect(401);\n\n      expect(response.body.success).toBe(false);\n    });\n\n    it('should reject request with invalid token', async () => {\n      const response = await request(app)\n        .get('/api/v1/auth/me')\n        .set('Authorization', 'Bearer invalid-token')\n        .expect(401);\n\n      expect(response.body.success).toBe(false);\n    });\n  });\n\n  describe('POST /api/v1/auth/logout', () => {\n    it('should reject unauthorized logout request', async () => {\n      const response = await request(app).post('/api/v1/auth/logout').expect(401);\n\n      expect(response.body.success).toBe(false);\n    });\n  });\n\n  describe('Rate Limiting', () => {\n    it('should enforce OTP rate limits', async () => {\n      const requests = [];\n\n      for (let i = 0; i < 6; i++) {\n        requests.push(\n          request(app)\n            .post('/api/v1/auth/register')\n            .send({\n              email: `ratelimit${i}@example.com`,\n              fullName: 'Rate Limit Test',\n            })\n        );\n      }\n\n      const responses = await Promise.all(requests);\n      const rateLimitedResponse = responses[responses.length - 1];\n\n      expect(rateLimitedResponse.status).toBe(429);\n    }, 10000);\n  });\n});\n","size_bytes":5381},"src/middleware/authMiddleware.ts":{"content":"import { Request, Response, NextFunction } from 'express';\nimport { tokenService } from '../modules/auth/token.service.js';\nimport { sessionService } from '../modules/auth/session.service.js';\nimport { JWTPayload } from '../modules/auth/auth.types.js';\nimport { sendError } from '../utils/response.js';\nimport { logger } from '../utils/logger.js';\n\ndeclare global {\n  namespace Express {\n    interface Request {\n      userId?: string;\n      sessionId?: string;\n      email?: string;\n    }\n  }\n}\n\nexport async function authenticateToken(\n  req: Request,\n  res: Response,\n  next: NextFunction\n): Promise<void> {\n  const authHeader = req.headers.authorization;\n\n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n    sendError(res, 'No token provided', 401, 'UNAUTHORIZED');\n    return;\n  }\n\n  const token = authHeader.substring(7);\n\n  try {\n    const payload: JWTPayload = await tokenService.verifyAccessToken(token);\n\n    const isSessionValid = await sessionService.isSessionValid(payload.sessionId);\n\n    if (!isSessionValid) {\n      sendError(res, 'Session has been revoked', 401, 'SESSION_REVOKED');\n      return;\n    }\n\n    req.userId = payload.userId;\n    req.sessionId = payload.sessionId;\n    req.email = payload.email;\n\n    await sessionService.updateSessionActivity(payload.sessionId);\n\n    next();\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Authentication failed';\n\n    logger.warn('Authentication failed', {\n      error: errorMessage,\n      ip: req.ip,\n      path: req.path,\n    });\n\n    if (errorMessage.includes('expired')) {\n      sendError(res, 'Access token expired', 401, 'TOKEN_EXPIRED');\n      return;\n    }\n\n    if (errorMessage.includes('Invalid')) {\n      sendError(res, 'Invalid access token', 401, 'INVALID_TOKEN');\n      return;\n    }\n\n    sendError(res, 'Authentication failed', 401, 'UNAUTHORIZED');\n  }\n}\n\nexport async function optionalAuthMiddleware(\n  req: Request,\n  _res: Response,\n  next: NextFunction\n): Promise<void> {\n  const authHeader = req.headers.authorization;\n\n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n    next();\n    return;\n  }\n\n  const token = authHeader.substring(7);\n\n  try {\n    const payload: JWTPayload = await tokenService.verifyAccessToken(token);\n\n    const isSessionValid = await sessionService.isSessionValid(payload.sessionId);\n\n    if (isSessionValid) {\n      req.userId = payload.userId;\n      req.sessionId = payload.sessionId;\n      req.email = payload.email;\n    }\n  } catch (error) {\n    logger.debug('Optional auth failed', { error });\n  }\n\n  next();\n}\n","size_bytes":2583},"src/utils/logger.ts":{"content":"import winston from 'winston';\nimport { env } from '../config/env.js';\n\nconst logFormat = winston.format.combine(\n  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),\n  winston.format.errors({ stack: true }),\n  winston.format.json()\n);\n\nexport const logger = winston.createLogger({\n  level: env.LOG_LEVEL,\n  format: logFormat,\n  defaultMeta: { service: 'biye-api' },\n  transports: [\n    new winston.transports.Console({\n      format: env.NODE_ENV === 'production'\n        ? logFormat\n        : winston.format.combine(\n            winston.format.colorize(),\n            winston.format.simple()\n          ),\n    }),\n  ],\n});\n\nexport function logRequest(requestId: string, method: string, path: string, statusCode?: number, duration?: number) {\n  const logData: Record<string, any> = {\n    requestId,\n    method,\n    path,\n  };\n\n  if (statusCode !== undefined) {\n    logData.statusCode = statusCode;\n  }\n\n  if (duration !== undefined) {\n    logData.duration = `${duration}ms`;\n  }\n\n  logger.info('HTTP Request', logData);\n}\n","size_bytes":1031},"replit.md":{"content":"# Biye Matrimonial Platform - Backend API\n\n## Overview\n\nA secure, production-ready backend API for a matrimonial platform built with Node.js, Express, and TypeScript. The system implements password + email OTP 2-step authentication with JWT access tokens and rotating refresh tokens stored in Redis. It includes a comprehensive profile management system with draft/publish workflow, step-by-step profile wizard, completeness tracking, and privacy controls.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Core Technology Stack\n\n**Runtime & Framework**\n- Node.js 18+ with Express.js framework\n- TypeScript with strict mode enabled for type safety\n- ES Modules (ESNext) for modern JavaScript features\n\n**Database & Caching**\n- PostgreSQL as the primary database via Prisma ORM\n- Redis for session management and refresh token storage\n- Prisma schema defines User and Session models with relationships\n\n### Authentication Architecture\n\n**OTP-Based Email Authentication**\n- Email-only authentication (no phone OTP)\n- 6-digit numeric OTP with 5-minute expiry\n- OTP hashed with bcrypt before storage in database\n- Rate limiting: 3 OTP requests per 15 minutes per email, 5 per IP\n- Separate flows for registration and login with OTP verification\n\n**Token Management**\n- JWT access tokens with 15-minute expiry\n- Rotating refresh tokens stored in Redis with 7-day expiry\n- Access tokens contain userId, email, and sessionId claims\n- Refresh token rotation on every refresh request\n- Token reuse detection for security\n\n**Session Tracking**\n- Device ID, IP address, and User Agent tracking\n- Session revocation support (individual and bulk)\n- Last activity timestamp updates\n- Session validation on every authenticated request\n\n### Security Architecture\n\n**Request Security**\n- Helmet middleware for security headers (CSP, HSTS, X-Frame-Options)\n- CORS middleware with origin whitelist validation\n- Rate limiting: 100 requests per 15 minutes globally, stricter limits on auth endpoints\n- Request ID tracking (UUID) for distributed tracing\n- Cookie security: HttpOnly, Secure (production), SameSite=strict\n\n**Validation & Error Handling**\n- Zod schemas for all request validation (body, query, params)\n- Centralized error handler with request context logging\n- Standardized JSON response format (success/error structure)\n- Environment variable validation on startup\n\n### API Architecture\n\n**Route Organization**\n- `/api/health` - Health check endpoint\n- `/api/v1/auth/*` - Authentication endpoints (register, verify, login, refresh, logout, me)\n- `/api/v1/profiles/*` - Profile management endpoints (CRUD, step updates, publish/unpublish)\n- Modular route structure with separate controller, service, and DTO layers\n\n**Response Format**\n```typescript\nSuccess: { success: true, data: T, message?: string }\nError: { success: false, error: { message, code?, details? } }\n```\n\n**Middleware Pipeline**\n1. Request ID assignment\n2. Request logging with duration tracking\n3. Helmet security headers\n4. CORS validation\n5. Rate limiting\n6. Body parsing (JSON/URL-encoded, 10MB limit)\n7. Cookie parsing\n8. Route handlers\n9. 404 handler\n10. Centralized error handler\n\n### Service Layer Architecture\n\n**Authentication Service** (`auth.service.ts`)\n- User registration with OTP generation\n- OTP verification with session creation\n- Login flow with existing user validation\n- Token refresh with rotation\n- Logout with session revocation\n- User profile retrieval\n\n**Token Service** (`token.service.ts`)\n- JWT access token generation and verification\n- Refresh token generation with Redis storage\n- Token rotation logic\n- Expiry parsing utilities\n\n**Session Service** (`session.service.ts`)\n- Session CRUD operations via Prisma\n- Session activity tracking\n- Bulk and individual session revocation\n- Active session retrieval\n\n**Email Service** (`email.service.ts`)\n- Real Nodemailer SMTP integration\n- OTP email delivery with HTML templates\n- Welcome email delivery\n- Development mode OTP logging\n\n**Profile Service** (`profile.service.ts`)\n- Profile creation (draft state)\n- Step-by-step profile updates (7 distinct steps)\n- Profile publishing with validation\n- Profile unpublishing\n- Profile retrieval with masking\n- Soft delete support\n\n**Completeness Service** (`completeness.service.ts`)\n- Dynamic completeness calculation (0-100%)\n- Weighted scoring for each profile section\n- Publish readiness validation\n- Missing fields detection\n\n**Profile Permissions** (`profile.permissions.ts`)\n- Field-level masking based on viewer permissions\n- Owner/Guardian/Premium/Visitor access levels\n- Photo privacy filtering\n- Location coordinate protection\n- About section truncation for non-premium users\n\n### Logging & Monitoring\n\n**Winston Logger**\n- Structured JSON logging in production\n- Colorized console output in development\n- Log levels: error, warn, info, http, verbose, debug, silly\n- Request correlation via request ID\n- Service-level default metadata\n\n**Request Logging**\n- HTTP method, path, status code\n- Request duration in milliseconds\n- Request ID for tracing\n\n### Testing Strategy\n\n**Jest Configuration**\n- ts-jest with ESM support\n- Unit tests in `__tests__` directories\n- Coverage collection from `src/**/*.ts`\n- Test environment: Node.js\n- Mock support for environment variables and external services\n\n## External Dependencies\n\n### Required Services\n\n**PostgreSQL Database**\n- Managed via Prisma ORM\n- Connection string in `DATABASE_URL` environment variable\n- Models:\n  - User (email, fullName, phoneNumber, passwordHash, isVerified, otpHash, otpExpiry)\n  - Session (userId, deviceId, ip, userAgent, revoked, lastSeenAt)\n  - Profile (userId, displayName, headline, about, gender, dob, location, published, completeness)\n  - Photo (profileId, objectKey, url, fileSize, privacyLevel, moderationStatus)\n  - Preference (profileId, basic, lifestyle, education, community, location)\n\n**Redis Cache**\n- ioredis client with connection retry logic\n- Connection string in `REDIS_URL` environment variable\n- Used for: refresh token storage, OTP rate limiting, token reuse detection\n- Automatic reconnection on errors\n\n### Third-Party NPM Packages\n\n**Production Dependencies**\n- `express` - Web framework\n- `@prisma/client` - Database ORM\n- `ioredis` - Redis client\n- `jsonwebtoken` - JWT token generation/verification\n- `bcryptjs` - Password/OTP hashing\n- `zod` - Schema validation\n- `helmet` - Security headers\n- `cors` - CORS handling\n- `express-rate-limit` - Rate limiting\n- `cookie-parser` - Cookie parsing\n- `winston` - Logging\n- `dotenv` - Environment variable loading\n\n**Development Dependencies**\n- `typescript` - Type system\n- `tsx` - TypeScript execution\n- `@typescript-eslint/*` - TypeScript linting\n- `jest` & `ts-jest` - Testing framework\n- `supertest` - HTTP assertion library\n- `prettier` - Code formatting\n- `eslint` - Code linting\n\n### Environment Variables\n\nRequired configuration:\n- `DATABASE_URL` - PostgreSQL connection string\n- `REDIS_URL` - Redis connection string\n- `JWT_SECRET` - Access token signing key (min 32 chars)\n- `JWT_REFRESH_SECRET` - Refresh token signing key (min 32 chars)\n- `JWT_ACCESS_EXPIRY` - Access token expiry (default: 15m)\n- `JWT_REFRESH_EXPIRY` - Refresh token expiry (default: 7d)\n- `EMAIL_HOST` - SMTP server host (e.g., smtp.gmail.com)\n- `EMAIL_PORT` - SMTP server port (default: 587)\n- `EMAIL_USER` - SMTP authentication username\n- `EMAIL_PASS` - SMTP authentication password\n- `EMAIL_FROM` - Email sender address\n- `NODE_ENV` - Environment (development/production/test)\n- `PORT` - Server port (default: 3000)\n- `LOG_LEVEL` - Winston log level (default: info)\n- `ALLOWED_ORIGINS` - Comma-separated CORS origins\n\n### Future Integration Points\n\n**Email Service Provider**\n- Real Nodemailer implementation with SMTP support\n- Configurable via environment variables (EMAIL_HOST, EMAIL_PORT, EMAIL_USER, EMAIL_PASS)\n- HTML email templates for OTP and welcome emails\n- Methods: `sendOTP()`, `sendWelcomeEmail()`\n\n**OpenAPI Documentation**\n- Authentication API: `openapi-auth.yaml`\n- Profile API: `openapi-profile.yaml`\n- Comprehensive documentation for all endpoints with examples","size_bytes":8161},"src/modules/profile/profile.service.ts":{"content":"import { PrismaClient } from '@prisma/client';\nimport { ProfileData, RequesterContext } from './profile.types.js';\nimport {\n  CreateProfileDTO,\n  StepUpdateDTO,\n  UpdatePhotosMetadataStepDTO,\n  UpdatePreferencesStepDTO,\n} from './profile.dto.js';\nimport { completenessService } from './completeness.service.js';\nimport { profilePermissions } from './profile.permissions.js';\nimport { logger } from '../../utils/logger.js';\n\nconst prisma = new PrismaClient();\n\nexport class ProfileService {\n  async createProfile(userId: string, dto: CreateProfileDTO): Promise<ProfileData> {\n    const existingProfile = await prisma.profile.findUnique({\n      where: { userId },\n      include: {\n        photos: true,\n        preferences: true,\n      },\n    });\n\n    if (existingProfile && !existingProfile.deletedAt) {\n      throw new Error('Profile already exists for this user');\n    }\n\n    const profile = await prisma.profile.create({\n      data: {\n        userId,\n        displayName: dto.displayName,\n        headline: dto.headline,\n        about: dto.about,\n        published: false,\n        completeness: 0,\n      },\n      include: {\n        photos: true,\n        preferences: true,\n      },\n    });\n\n    const completeness = completenessService.calculateCompleteness(profile as ProfileData);\n\n    const updatedProfile = await prisma.profile.update({\n      where: { id: profile.id },\n      data: { completeness },\n      include: {\n        photos: true,\n        preferences: true,\n      },\n    });\n\n    logger.info('Profile created', { userId, profileId: updatedProfile.id });\n\n    return updatedProfile as ProfileData;\n  }\n\n  async getMyProfile(userId: string): Promise<ProfileData | null> {\n    const profile = await prisma.profile.findUnique({\n      where: { userId },\n      include: {\n        photos: true,\n        preferences: true,\n      },\n    });\n\n    if (!profile || profile.deletedAt) {\n      return null;\n    }\n\n    return profile as ProfileData;\n  }\n\n  async getProfileById(profileId: string, requester: RequesterContext): Promise<ProfileData> {\n    const profile = await prisma.profile.findUnique({\n      where: { id: profileId },\n      include: {\n        photos: true,\n        preferences: true,\n      },\n    });\n\n    if (!profile || profile.deletedAt) {\n      throw new Error('Profile not found');\n    }\n\n    const canView = profilePermissions.canViewProfile(profile as ProfileData, requester);\n\n    if (!canView) {\n      throw new Error('You do not have permission to view this profile');\n    }\n\n    return profile as ProfileData;\n  }\n\n  async updateProfileStep(\n    profileId: string,\n    userId: string,\n    stepData: StepUpdateDTO\n  ): Promise<ProfileData> {\n    const profile = await prisma.profile.findUnique({\n      where: { id: profileId },\n      include: {\n        photos: true,\n        preferences: true,\n      },\n    });\n\n    if (!profile || profile.deletedAt) {\n      throw new Error('Profile not found');\n    }\n\n    if (profile.userId !== userId) {\n      throw new Error('You do not have permission to update this profile');\n    }\n\n    let updatedProfile: any;\n\n    switch (stepData.step) {\n      case 'about':\n        updatedProfile = await prisma.profile.update({\n          where: { id: profileId },\n          data: {\n            about: stepData.data.about,\n            headline: stepData.data.headline || profile.headline,\n          },\n          include: {\n            photos: true,\n            preferences: true,\n          },\n        });\n        break;\n\n      case 'demographics':\n        updatedProfile = await prisma.profile.update({\n          where: { id: profileId },\n          data: {\n            gender: stepData.data.gender,\n            dob: new Date(stepData.data.dob),\n          },\n          include: {\n            photos: true,\n            preferences: true,\n          },\n        });\n        break;\n\n      case 'family':\n        updatedProfile = await prisma.profile.update({\n          where: { id: profileId },\n          data: {\n            location: {\n              ...(profile.location as any),\n              family: stepData.data.familyDetails,\n            },\n          },\n          include: {\n            photos: true,\n            preferences: true,\n          },\n        });\n        break;\n\n      case 'lifestyle':\n        updatedProfile = await prisma.profile.update({\n          where: { id: profileId },\n          data: {\n            location: {\n              ...(profile.location as any),\n              lifestyle: stepData.data.lifestyle,\n            },\n          },\n          include: {\n            photos: true,\n            preferences: true,\n          },\n        });\n        break;\n\n      case 'location':\n        updatedProfile = await prisma.profile.update({\n          where: { id: profileId },\n          data: {\n            location: stepData.data.location,\n          },\n          include: {\n            photos: true,\n            preferences: true,\n          },\n        });\n        break;\n\n      case 'photos-metadata':\n        await prisma.photo.deleteMany({\n          where: { profileId },\n        });\n\n        await prisma.photo.createMany({\n          data: stepData.data.photos.map((photo) => ({\n            profileId,\n            objectKey: photo.objectKey,\n            url: photo.url,\n            fileSize: photo.fileSize,\n            privacyLevel: photo.privacyLevel,\n          })),\n        });\n\n        updatedProfile = await prisma.profile.findUnique({\n          where: { id: profileId },\n          include: {\n            photos: true,\n            preferences: true,\n          },\n        });\n        break;\n\n      case 'preferences':\n        const existingPreferences = await prisma.preference.findUnique({\n          where: { profileId },\n        });\n\n        if (existingPreferences) {\n          await prisma.preference.update({\n            where: { profileId },\n            data: {\n              basic: stepData.data.preferences.basic || existingPreferences.basic,\n              lifestyle: stepData.data.preferences.lifestyle || existingPreferences.lifestyle,\n              education: stepData.data.preferences.education || existingPreferences.education,\n              community: stepData.data.preferences.community || existingPreferences.community,\n              location: stepData.data.preferences.location || existingPreferences.location,\n            },\n          });\n        } else {\n          await prisma.preference.create({\n            data: {\n              profileId,\n              basic: stepData.data.preferences.basic,\n              lifestyle: stepData.data.preferences.lifestyle,\n              education: stepData.data.preferences.education,\n              community: stepData.data.preferences.community,\n              location: stepData.data.preferences.location,\n            },\n          });\n        }\n\n        updatedProfile = await prisma.profile.findUnique({\n          where: { id: profileId },\n          include: {\n            photos: true,\n            preferences: true,\n          },\n        });\n        break;\n\n      default:\n        throw new Error('Invalid step');\n    }\n\n    const completeness = completenessService.calculateCompleteness(updatedProfile as ProfileData);\n\n    const finalProfile = await prisma.profile.update({\n      where: { id: profileId },\n      data: { completeness },\n      include: {\n        photos: true,\n        preferences: true,\n      },\n    });\n\n    logger.info('Profile step updated', {\n      profileId,\n      step: stepData.step,\n      completeness,\n    });\n\n    return finalProfile as ProfileData;\n  }\n\n  async publishProfile(profileId: string, userId: string): Promise<ProfileData> {\n    const profile = await prisma.profile.findUnique({\n      where: { id: profileId },\n      include: {\n        photos: true,\n        preferences: true,\n      },\n    });\n\n    if (!profile || profile.deletedAt) {\n      throw new Error('Profile not found');\n    }\n\n    if (profile.userId !== userId) {\n      throw new Error('You do not have permission to publish this profile');\n    }\n\n    const { canPublish, missingFields } = completenessService.canPublish(profile as ProfileData);\n\n    if (!canPublish) {\n      throw new Error(\n        `Profile cannot be published. Missing required fields: ${missingFields.join(', ')}`\n      );\n    }\n\n    const updatedProfile = await prisma.profile.update({\n      where: { id: profileId },\n      data: { published: true },\n      include: {\n        photos: true,\n        preferences: true,\n      },\n    });\n\n    logger.info('Profile published', { profileId, userId });\n\n    return updatedProfile as ProfileData;\n  }\n\n  async unpublishProfile(profileId: string, userId: string): Promise<ProfileData> {\n    const profile = await prisma.profile.findUnique({\n      where: { id: profileId },\n    });\n\n    if (!profile || profile.deletedAt) {\n      throw new Error('Profile not found');\n    }\n\n    if (profile.userId !== userId) {\n      throw new Error('You do not have permission to unpublish this profile');\n    }\n\n    const updatedProfile = await prisma.profile.update({\n      where: { id: profileId },\n      data: { published: false },\n      include: {\n        photos: true,\n        preferences: true,\n      },\n    });\n\n    logger.info('Profile unpublished', { profileId, userId });\n\n    return updatedProfile as ProfileData;\n  }\n\n  async softDeleteProfile(profileId: string, userId: string): Promise<void> {\n    const profile = await prisma.profile.findUnique({\n      where: { id: profileId },\n    });\n\n    if (!profile) {\n      throw new Error('Profile not found');\n    }\n\n    if (profile.userId !== userId) {\n      throw new Error('You do not have permission to delete this profile');\n    }\n\n    await prisma.profile.update({\n      where: { id: profileId },\n      data: {\n        deletedAt: new Date(),\n        published: false,\n      },\n    });\n\n    logger.info('Profile soft deleted', { profileId, userId });\n  }\n}\n\nexport const profileService = new ProfileService();\n","size_bytes":9899},"src/config/redis.ts":{"content":"import Redis from 'ioredis';\nimport { env } from './env.js';\nimport { logger } from '../utils/logger.js';\n\nlet redisClient: Redis | null = null;\n\nexport function getRedisClient(): Redis {\n  if (!redisClient) {\n    redisClient = new Redis(env.REDIS_URL, {\n      maxRetriesPerRequest: 3,\n      retryStrategy(times) {\n        const delay = Math.min(times * 50, 2000);\n        return delay;\n      },\n      reconnectOnError(err) {\n        const targetError = 'READONLY';\n        if (err.message.includes(targetError)) {\n          return true;\n        }\n        return false;\n      },\n    });\n\n    redisClient.on('error', (err) => {\n      logger.error('Redis client error:', { error: err.message });\n    });\n\n    redisClient.on('connect', () => {\n      logger.info('Redis client connected');\n    });\n\n    redisClient.on('ready', () => {\n      logger.info('Redis client ready');\n    });\n  }\n\n  return redisClient;\n}\n\nexport async function disconnectRedis(): Promise<void> {\n  if (redisClient) {\n    await redisClient.quit();\n    redisClient = null;\n    logger.info('Redis client disconnected');\n  }\n}\n\nexport const redis = getRedisClient();\n","size_bytes":1134},"PROFILE_MODULE_README.md":{"content":"# Profile Module - Biye Matrimonial Platform\n\n## Overview\n\nThe Profile Module implements a comprehensive profile management system with a **draft â†’ publish** workflow, step-by-step profile wizard, completeness tracking, privacy controls, and permission-based field masking.\n\n---\n\n## Features\n\nâœ… **Draft/Publish Workflow** - Users create draft profiles and publish when ready  \nâœ… **Step-by-Step Profile Wizard** - 7 distinct steps for gradual profile building  \nâœ… **Completeness Meter** - Dynamic calculation (0-100%) based on filled sections  \nâœ… **Photo Metadata Linking** - Track photos with privacy levels and moderation status  \nâœ… **Partner Preferences** - Comprehensive preference system with JSON flexibility  \nâœ… **Profile Masking** - Field-level privacy based on viewer permissions  \nâœ… **Publish Requirements** - Validation of mandatory fields before publishing  \nâœ… **Soft Delete** - Profiles can be deleted without permanent data loss  \n\n---\n\n## Database Models\n\n### Profile Model\n\n```prisma\nmodel Profile {\n  id           String      @id @default(uuid())\n  userId       String      @unique\n  displayName  String\n  headline     String?\n  about        String?\n  gender       String?\n  dob          DateTime?\n  location     Json?\n  published    Boolean     @default(false)\n  completeness Int         @default(0)\n  photos       Photo[]\n  preferences  Preference?\n  createdAt    DateTime    @default(now())\n  updatedAt    DateTime    @updatedAt\n  deletedAt    DateTime?\n  user         User        @relation(fields: [userId], references: [id])\n}\n```\n\n### Photo Model\n\n```prisma\nmodel Photo {\n  id               String   @id @default(uuid())\n  profileId        String\n  objectKey        String?\n  url              String?\n  fileSize         Int?\n  privacyLevel     String   @default(\"public\")    # public, private, on_request\n  moderationStatus String   @default(\"pending\")   # pending, approved, rejected\n  createdAt        DateTime @default(now())\n  profile          Profile  @relation(fields: [profileId], references: [id])\n}\n```\n\n### Preference Model\n\n```prisma\nmodel Preference {\n  id        String   @id @default(uuid())\n  profileId String   @unique\n  basic     Json?\n  lifestyle Json?\n  education Json?\n  community Json?\n  location  Json?\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n  profile   Profile  @relation(fields: [profileId], references: [id])\n}\n```\n\n---\n\n## API Endpoints\n\n### 1. Create Profile\n\n**POST** `/api/v1/profiles`\n\nCreate a new profile draft for the authenticated user.\n\n**Request:**\n```json\n{\n  \"displayName\": \"John Doe\",\n  \"headline\": \"Software Engineer from NYC\",\n  \"about\": \"I am a passionate developer looking for a life partner...\"\n}\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"id\": \"profile-uuid\",\n    \"userId\": \"user-uuid\",\n    \"displayName\": \"John Doe\",\n    \"headline\": \"Software Engineer from NYC\",\n    \"about\": \"I am a passionate developer...\",\n    \"published\": false,\n    \"completeness\": 25,\n    \"createdAt\": \"2025-01-01T00:00:00Z\",\n    \"updatedAt\": \"2025-01-01T00:00:00Z\"\n  },\n  \"message\": \"Profile created successfully\"\n}\n```\n\n---\n\n### 2. Get My Profile\n\n**GET** `/api/v1/profiles/me`\n\nRetrieve the authenticated user's profile (draft or published).\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"id\": \"profile-uuid\",\n    \"userId\": \"user-uuid\",\n    \"displayName\": \"John Doe\",\n    \"completeness\": 75,\n    \"published\": false,\n    \"photos\": [...],\n    \"preferences\": {...}\n  }\n}\n```\n\n---\n\n### 3. Get Profile by ID\n\n**GET** `/api/v1/profiles/:id`\n\nRetrieve a profile by ID. **Profile masking applied** based on viewer permissions.\n\n**Masking Rules:**\n- **Owner**: Sees all fields\n- **Premium/Guardian**: Sees all public + some private fields\n- **Regular Visitor**: Sees only public fields, truncated about, public photos only\n\n**Response (Masked):**\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"id\": \"profile-uuid\",\n    \"displayName\": \"John Doe\",\n    \"headline\": \"Software Engineer from NYC\",\n    \"about\": \"I am a passionate developer...\",  // Truncated to 150 chars for visitors\n    \"gender\": \"male\",\n    \"age\": 28,\n    \"location\": {\n      \"city\": \"New York\",\n      \"state\": \"NY\",\n      \"country\": \"USA\"\n      // Coordinates removed for privacy\n    },\n    \"completeness\": 85,\n    \"photos\": [\n      // Only public photos shown\n    ]\n  }\n}\n```\n\n---\n\n### 4. Update Profile Step\n\n**PATCH** `/api/v1/profiles/:id/step`\n\nUpdate a specific step in the profile wizard.\n\n#### Available Steps:\n\n1. **about** - Update about and headline\n2. **demographics** - Update gender and date of birth\n3. **family** - Update family details\n4. **lifestyle** - Update lifestyle preferences\n5. **location** - Update location information\n6. **photos-metadata** - Link photo metadata\n7. **preferences** - Update partner preferences\n\n#### Example: Update About Step\n\n**Request:**\n```json\n{\n  \"step\": \"about\",\n  \"data\": {\n    \"about\": \"I am a software engineer with 5+ years of experience...\",\n    \"headline\": \"Tech Professional seeking Life Partner\"\n  }\n}\n```\n\n#### Example: Update Demographics Step\n\n**Request:**\n```json\n{\n  \"step\": \"demographics\",\n  \"data\": {\n    \"gender\": \"male\",\n    \"dob\": \"1995-03-15\"\n  }\n}\n```\n\n#### Example: Update Location Step\n\n**Request:**\n```json\n{\n  \"step\": \"location\",\n  \"data\": {\n    \"location\": {\n      \"city\": \"New York\",\n      \"state\": \"NY\",\n      \"country\": \"USA\",\n      \"coordinates\": {\n        \"lat\": 40.7128,\n        \"lng\": -74.0060\n      }\n    }\n  }\n}\n```\n\n#### Example: Update Photos Metadata Step\n\n**Request:**\n```json\n{\n  \"step\": \"photos-metadata\",\n  \"data\": {\n    \"photos\": [\n      {\n        \"objectKey\": \"user-123/photo-1.jpg\",\n        \"url\": \"https://cdn.biye.com/photos/photo-1.jpg\",\n        \"fileSize\": 204800,\n        \"privacyLevel\": \"public\"\n      },\n      {\n        \"objectKey\": \"user-123/photo-2.jpg\",\n        \"url\": \"https://cdn.biye.com/photos/photo-2.jpg\",\n        \"fileSize\": 153600,\n        \"privacyLevel\": \"private\"\n      }\n    ]\n  }\n}\n```\n\n#### Example: Update Preferences Step\n\n**Request:**\n```json\n{\n  \"step\": \"preferences\",\n  \"data\": {\n    \"preferences\": {\n      \"basic\": {\n        \"ageRange\": { \"min\": 25, \"max\": 35 },\n        \"heightRange\": { \"min\": 160, \"max\": 180 },\n        \"maritalStatus\": [\"never_married\", \"divorced\"]\n      },\n      \"lifestyle\": {\n        \"diet\": [\"vegetarian\", \"vegan\"],\n        \"drinking\": [\"never\"],\n        \"smoking\": [\"never\"]\n      },\n      \"education\": {\n        \"minEducation\": \"bachelors\",\n        \"fieldOfStudy\": [\"engineering\", \"business\"]\n      },\n      \"location\": {\n        \"cities\": [\"New York\", \"Boston\", \"San Francisco\"],\n        \"countries\": [\"USA\", \"Canada\"],\n        \"willingToRelocate\": true\n      }\n    }\n  }\n}\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"id\": \"profile-uuid\",\n    \"completeness\": 80,  // Updated based on new data\n    ...\n  },\n  \"message\": \"Profile step updated successfully\"\n}\n```\n\n---\n\n### 5. Publish Profile\n\n**POST** `/api/v1/profiles/:id/publish`\n\nPublish the profile (makes it visible to others).\n\n**Required Fields for Publishing:**\n- âœ… displayName (min 2 chars)\n- âœ… gender\n- âœ… dob (age 18-100)\n- âœ… location (city, state, country)\n- âœ… about (min 50 chars)\n- âœ… headline (min 10 chars)\n- âœ… At least 1 photo\n\n**Success Response:**\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"id\": \"profile-uuid\",\n    \"published\": true,\n    \"completeness\": 90\n  },\n  \"message\": \"Profile published successfully\"\n}\n```\n\n**Error Response (Incomplete):**\n```json\n{\n  \"success\": false,\n  \"error\": {\n    \"message\": \"Profile cannot be published. Missing required fields: gender, dob, photos (at least 1 required)\"\n  }\n}\n```\n\n---\n\n### 6. Unpublish Profile\n\n**POST** `/api/v1/profiles/:id/unpublish`\n\nUnpublish the profile (hides it from others).\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"id\": \"profile-uuid\",\n    \"published\": false\n  },\n  \"message\": \"Profile unpublished successfully\"\n}\n```\n\n---\n\n### 7. Delete Profile\n\n**DELETE** `/api/v1/profiles/:id`\n\nSoft delete the profile (owner only).\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"message\": \"Profile deleted successfully\"\n}\n```\n\n---\n\n## Completeness Calculation\n\nThe completeness score (0-100%) is calculated based on weighted sections:\n\n| Section | Weight | Criteria |\n|---------|--------|----------|\n| Display Name | 10% | Length >= 2 chars |\n| Headline | 10% | Length >= 10 chars |\n| About | 15% | Length >= 50 chars |\n| Gender | 10% | Not null |\n| Date of Birth | 10% | Not null, age 18-100 |\n| Location | 15% | Valid city, state, country |\n| Photos | 20% | At least 1 photo |\n| Preferences | 10% | Not null |\n\n**Total:** 100%\n\n**Example:**\n- Profile with displayName, gender, dob, and 1 photo = 50% complete\n- Profile with all fields = 100% complete\n\n---\n\n## Profile Masking & Privacy\n\n### Visibility Levels:\n\n#### 1. **Owner** (userId matches profile.userId)\n- âœ… Full access to all fields\n- âœ… Can see unpublished profiles\n- âœ… Can see private photos\n- âœ… Can see complete about section\n- âœ… Can see exact location coordinates\n\n#### 2. **Guardian/Premium User**\n- âœ… Can see published profiles only\n- âœ… Can see all public photos\n- âœ… Can see complete about section\n- âœ… Can see location (city/state/country, no coordinates)\n- âœ… Can see partner preferences\n\n#### 3. **Regular Visitor**\n- âœ… Can see published profiles only\n- âœ… Can see public photos only\n- âœ… About section truncated to 150 characters\n- âœ… Location limited to city/state/country (no coordinates)\n- âŒ Cannot see private photos\n- âŒ Cannot see \"on_request\" photos\n\n### Photo Privacy Levels:\n\n- **public**: Visible to all visitors\n- **private**: Visible to owner and guardians only\n- **on_request**: Visible after connection request accepted\n\n---\n\n## Validation Rules\n\n### Registration Validation:\n- `displayName`: Min 2 characters\n- `headline`: Min 10 characters (optional at creation)\n- `about`: Min 50 characters (optional at creation)\n\n### Demographics Validation:\n- `gender`: Must be \"male\", \"female\", or \"other\"\n- `dob`: Age must be 18-100 years\n\n### Location Validation:\n- `city`: Min 2 characters\n- `state`: Min 2 characters\n- `country`: Min 2 characters\n\n### Photos Validation:\n- `url`: Must be valid URL\n- `fileSize`: Must be positive integer\n- `privacyLevel`: Must be \"public\", \"private\", or \"on_request\"\n\n---\n\n## Security & Permissions\n\n### Authorization Checks:\n\n1. **Profile Creation**: Authenticated users only\n2. **Profile Viewing**: \n   - Owner: Can view draft or published\n   - Others: Can only view published profiles\n3. **Profile Editing**: Owner only\n4. **Profile Publishing**: Owner only\n5. **Profile Deletion**: Owner only\n\n### Access Control:\n\n```typescript\n// Example permission check\nconst canView = profilePermissions.canViewProfile(profile, requester);\nif (!canView) {\n  throw new Error('You do not have permission to view this profile');\n}\n```\n\n---\n\n## Usage Examples\n\n### Complete Profile Wizard Flow:\n\n```javascript\n// 1. Create profile\nPOST /api/v1/profiles\n{\n  \"displayName\": \"Jane Smith\"\n}\n\n// 2. Update about\nPATCH /api/v1/profiles/{id}/step\n{\n  \"step\": \"about\",\n  \"data\": {\n    \"about\": \"I am a teacher with a passion for education and lifelong learning...\",\n    \"headline\": \"Educator seeking meaningful connection\"\n  }\n}\n\n// 3. Update demographics\nPATCH /api/v1/profiles/{id}/step\n{\n  \"step\": \"demographics\",\n  \"data\": {\n    \"gender\": \"female\",\n    \"dob\": \"1992-07-20\"\n  }\n}\n\n// 4. Update location\nPATCH /api/v1/profiles/{id}/step\n{\n  \"step\": \"location\",\n  \"data\": {\n    \"location\": {\n      \"city\": \"Boston\",\n      \"state\": \"MA\",\n      \"country\": \"USA\"\n    }\n  }\n}\n\n// 5. Add photos\nPATCH /api/v1/profiles/{id}/step\n{\n  \"step\": \"photos-metadata\",\n  \"data\": {\n    \"photos\": [\n      {\n        \"objectKey\": \"user-456/profile.jpg\",\n        \"url\": \"https://cdn.biye.com/photos/profile.jpg\",\n        \"fileSize\": 256000,\n        \"privacyLevel\": \"public\"\n      }\n    ]\n  }\n}\n\n// 6. Publish profile\nPOST /api/v1/profiles/{id}/publish\n```\n\n---\n\n## Error Handling\n\nAll endpoints return standardized error responses:\n\n```json\n{\n  \"success\": false,\n  \"error\": {\n    \"message\": \"Error description\",\n    \"code\": \"ERROR_CODE\",\n    \"details\": {}\n  }\n}\n```\n\n### Common Error Codes:\n- `VALIDATION_ERROR`: Request validation failed\n- `NOT_FOUND`: Profile not found\n- `UNAUTHORIZED`: Authentication required\n- `FORBIDDEN`: Insufficient permissions\n- `CONFLICT`: Profile already exists\n\n---\n\n## Testing\n\nUnit tests are provided in `profile.test.ts` (run locally):\n\n```bash\nnpm test src/modules/profile/profile.test.ts\n```\n\n**Test Coverage:**\n- âœ… Profile creation\n- âœ… Step updates\n- âœ… Publish validation\n- âœ… Completeness calculation\n- âœ… Profile masking\n- âœ… Permission checks\n\n---\n\n## Migration Commands\n\nRun these commands locally:\n\n```bash\n# Generate Prisma client\nnpx prisma generate\n\n# Create migration\nnpx prisma migrate dev --name add_profile_models\n\n# Apply migration\nnpx prisma migrate deploy\n```\n\n---\n\n## OpenAPI Documentation\n\nFull OpenAPI spec available in `openapi-profile.yaml`.\n\nView with Swagger UI:\n```bash\n# Install swagger-ui-express\nnpm install swagger-ui-express\n\n# Serve at /api-docs\n```\n\n---\n\n## Next Steps\n\n1. **Photo Upload Integration** - Implement actual photo upload to object storage\n2. **Search & Filtering** - Add profile search with preference matching\n3. **Matching Algorithm** - Implement compatibility scoring\n4. **Guardian System** - Add guardian account linking\n5. **Premium Features** - Implement premium user benefits\n6. **Notifications** - Profile view notifications\n7. **Analytics** - Track profile completeness and engagement\n","size_bytes":13589},"src/middleware/cors.ts":{"content":"import cors from 'cors';\nimport { env } from '../config/env.js';\n\nexport const corsMiddleware = cors({\n  origin: (origin, callback) => {\n    if (!origin || env.ALLOWED_ORIGINS.includes(origin) || env.ALLOWED_ORIGINS.includes('*')) {\n      callback(null, true);\n    } else {\n      callback(new Error('Not allowed by CORS'));\n    }\n  },\n  credentials: true,\n  methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],\n  allowedHeaders: ['Content-Type', 'Authorization', 'X-Request-Id', 'Idempotency-Key'],\n  exposedHeaders: ['X-Request-Id'],\n  maxAge: 86400,\n});\n","size_bytes":566},"src/utils/idempotency.ts":{"content":"import { Request } from 'express';\n\nexport function getIdempotencyKey(req: Request): string | null {\n  return req.headers['idempotency-key'] as string || null;\n}\n\nexport function validateIdempotencyKey(key: string): boolean {\n  return typeof key === 'string' && key.length > 0 && key.length <= 255;\n}\n","size_bytes":301},"src/modules/auth/email.service.ts":{"content":"import nodemailer from 'nodemailer';\nimport { logger } from '../../utils/logger.js';\n\nconst transporter = nodemailer.createTransport({\n  host: process.env.EMAIL_HOST || 'smtp.ethereal.email',\n  port: Number(process.env.EMAIL_PORT) || 587,\n  secure: false,\n  auth: {\n    user: process.env.EMAIL_USER,\n    pass: process.env.EMAIL_PASS,\n  },\n});\n\nexport class EmailService {\n  async sendOTP(email: string, otp: string, type: 'register' | 'login'): Promise<void> {\n    logger.info(`[EmailService] Sending OTP to ${email}`, {\n      type,\n      otpLength: otp.length,\n    });\n\n    if (process.env.NODE_ENV === 'development') {\n      logger.debug(`[EmailService] OTP for ${email}: ${otp}`);\n    }\n\n    const html = `\n      <div style=\"font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;\">\n        <h2>Your Biye OTP Code</h2>\n        <p>Your OTP is <strong style=\"font-size: 24px; color: #4CAF50;\">${otp}</strong></p>\n        <p>This code is valid for <strong>5 minutes</strong>.</p>\n        <p>If you didn't request this code, please ignore this email.</p>\n        <hr style=\"margin-top: 20px; border: none; border-top: 1px solid #ddd;\">\n        <p style=\"color: #888; font-size: 12px;\">This is an automated email from Biye. Please do not reply.</p>\n      </div>\n    `;\n\n    try {\n      await transporter.sendMail({\n        from: process.env.EMAIL_FROM || '\"Biye\" <noreply@biye.com>',\n        to: email,\n        subject: 'Your Biye OTP Code',\n        html,\n      });\n\n      logger.info(`[EmailService] OTP email sent successfully to ${email}`);\n    } catch (error) {\n      logger.error(`[EmailService] Failed to send OTP email to ${email}`, { error });\n      throw new Error('Failed to send OTP email');\n    }\n  }\n\n  async sendWelcomeEmail(email: string, fullName?: string): Promise<void> {\n    logger.info(`[EmailService] Sending welcome email to ${email}`, {\n      fullName,\n    });\n\n    const html = `\n      <div style=\"font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;\">\n        <h2>Welcome to Biye!</h2>\n        <p>Hi ${fullName || 'there'},</p>\n        <p>Thank you for registering with Biye. Your account has been successfully verified.</p>\n        <p>You can now log in and start exploring our platform.</p>\n        <hr style=\"margin-top: 20px; border: none; border-top: 1px solid #ddd;\">\n        <p style=\"color: #888; font-size: 12px;\">This is an automated email from Biye. Please do not reply.</p>\n      </div>\n    `;\n\n    try {\n      await transporter.sendMail({\n        from: process.env.EMAIL_FROM || '\"Biye\" <noreply@biye.com>',\n        to: email,\n        subject: 'Welcome to Biye!',\n        html,\n      });\n\n      logger.info(`[EmailService] Welcome email sent successfully to ${email}`);\n    } catch (error) {\n      logger.error(`[EmailService] Failed to send welcome email to ${email}`, { error });\n    }\n  }\n}\n\nexport const emailService = new EmailService();\n","size_bytes":2902},"src/modules/profile/profile.routes.ts":{"content":"import { Router } from 'express';\nimport { profileController } from './profile.controller.js';\nimport { authenticateToken } from '../../middleware/authMiddleware.js';\n// import { validate } from '../../middleware/validate.js';\nimport { validate } from 'middleware/validate.js';\nimport {\n  CreateProfileSchema,\n  StepUpdateSchema,\n} from './profile.dto.js';\n\nconst router = Router();\n\nrouter.post(\n  '/',\n  authenticateToken,\n  validate(CreateProfileSchema),\n  profileController.createProfile.bind(profileController)\n);\n\nrouter.get('/me', authenticateToken, profileController.getMyProfile.bind(profileController));\n\nrouter.get('/:id', authenticateToken, profileController.getProfileById.bind(profileController));\n\nrouter.patch(\n  '/:id/step',\n  authenticateToken,\n  validate(StepUpdateSchema),\n  profileController.updateProfileStep.bind(profileController)\n);\n\nrouter.post('/:id/publish', authenticateToken, profileController.publishProfile.bind(profileController));\n\nrouter.post(\n  '/:id/unpublish',\n  authenticateToken,\n  profileController.unpublishProfile.bind(profileController)\n);\n\nrouter.delete('/:id', authenticateToken, profileController.deleteProfile.bind(profileController));\n\nexport default router;\n","size_bytes":1208},"src/modules/auth/auth.types.ts":{"content":"export interface TokenPair {\n  accessToken: string;\n  refreshToken: string;\n}\n\nexport interface AuthResponse {\n  accessToken: string;\n  refreshToken: string;\n  user: UserResponse;\n}\n\nexport interface UserResponse {\n  id: string;\n  email: string;\n  fullName: string | null;\n  phoneNumber: string | null;\n  isVerified: boolean;\n  createdAt: Date;\n}\n\nexport interface SessionInfo {\n  deviceId?: string;\n  ip?: string;\n  userAgent?: string;\n}\n\nexport interface JWTPayload {\n  userId: string;\n  email: string;\n  sessionId: string;\n}\n\nexport interface RefreshTokenData {\n  userId: string;\n  sessionId: string;\n  tokenHash: string;\n  createdAt: number;\n}\n\nexport interface OTPData {\n  otpHash: string;\n  otpExpiry: Date;\n}\n","size_bytes":716},"src/modules/profile/profile.test.ts":{"content":"import { describe, it, expect, beforeEach, jest } from '@jest/globals';\nimport { ProfileService } from './profile.service.js';\nimport { CompletenessService } from './completeness.service.js';\nimport { ProfilePermissions } from './profile.permissions.js';\n\ndescribe('ProfileService', () => {\n  let profileService: ProfileService;\n\n  beforeEach(() => {\n    profileService = new ProfileService();\n  });\n\n  describe('createProfile', () => {\n    it('should create a new profile with initial data', async () => {\n      const userId = 'user-123';\n      const dto = {\n        displayName: 'John Doe',\n        headline: 'Software Engineer',\n        about: 'I am a passionate developer...',\n      };\n\n      const profile = await profileService.createProfile(userId, dto);\n\n      expect(profile).toBeDefined();\n      expect(profile.userId).toBe(userId);\n      expect(profile.displayName).toBe(dto.displayName);\n      expect(profile.published).toBe(false);\n      expect(profile.completeness).toBeGreaterThanOrEqual(0);\n    });\n\n    it('should throw error if profile already exists', async () => {\n      const userId = 'user-123';\n      const dto = {\n        displayName: 'John Doe',\n      };\n\n      await profileService.createProfile(userId, dto);\n\n      await expect(profileService.createProfile(userId, dto)).rejects.toThrow(\n        'Profile already exists'\n      );\n    });\n  });\n\n  describe('updateProfileStep', () => {\n    it('should update about step', async () => {\n      const userId = 'user-123';\n      const profile = await profileService.createProfile(userId, {\n        displayName: 'John Doe',\n      });\n\n      const stepData = {\n        step: 'about' as const,\n        data: {\n          about: 'This is a longer about section with at least 50 characters to pass validation.',\n          headline: 'New headline',\n        },\n      };\n\n      const updated = await profileService.updateProfileStep(profile.id, userId, stepData);\n\n      expect(updated.about).toBe(stepData.data.about);\n      expect(updated.headline).toBe(stepData.data.headline);\n    });\n\n    it('should update demographics step', async () => {\n      const userId = 'user-123';\n      const profile = await profileService.createProfile(userId, {\n        displayName: 'John Doe',\n      });\n\n      const stepData = {\n        step: 'demographics' as const,\n        data: {\n          gender: 'male' as const,\n          dob: '1990-01-01',\n        },\n      };\n\n      const updated = await profileService.updateProfileStep(profile.id, userId, stepData);\n\n      expect(updated.gender).toBe('male');\n      expect(updated.dob).toBeDefined();\n    });\n\n    it('should throw error if user is not owner', async () => {\n      const userId = 'user-123';\n      const otherUserId = 'user-456';\n\n      const profile = await profileService.createProfile(userId, {\n        displayName: 'John Doe',\n      });\n\n      const stepData = {\n        step: 'about' as const,\n        data: {\n          about: 'Trying to update someone else profile',\n        },\n      };\n\n      await expect(\n        profileService.updateProfileStep(profile.id, otherUserId, stepData)\n      ).rejects.toThrow('permission');\n    });\n  });\n\n  describe('publishProfile', () => {\n    it('should throw error if required fields are missing', async () => {\n      const userId = 'user-123';\n      const profile = await profileService.createProfile(userId, {\n        displayName: 'John Doe',\n      });\n\n      await expect(profileService.publishProfile(profile.id, userId)).rejects.toThrow(\n        'Missing required fields'\n      );\n    });\n\n    it('should publish profile if all required fields are present', async () => {\n      const userId = 'user-123';\n      const profile = await profileService.createProfile(userId, {\n        displayName: 'John Doe',\n        headline: 'Software Engineer',\n        about: 'This is a detailed about section with more than 50 characters.',\n      });\n\n      await profileService.updateProfileStep(profile.id, userId, {\n        step: 'demographics',\n        data: {\n          gender: 'male',\n          dob: '1990-01-01',\n        },\n      });\n\n      await profileService.updateProfileStep(profile.id, userId, {\n        step: 'location',\n        data: {\n          location: {\n            city: 'New York',\n            state: 'NY',\n            country: 'USA',\n          },\n        },\n      });\n\n      await profileService.updateProfileStep(profile.id, userId, {\n        step: 'photos-metadata',\n        data: {\n          photos: [\n            {\n              objectKey: 'photo-1.jpg',\n              url: 'https://example.com/photo-1.jpg',\n              fileSize: 1024,\n              privacyLevel: 'public' as const,\n            },\n          ],\n        },\n      });\n\n      const published = await profileService.publishProfile(profile.id, userId);\n\n      expect(published.published).toBe(true);\n    });\n  });\n});\n\ndescribe('CompletenessService', () => {\n  let completenessService: CompletenessService;\n\n  beforeEach(() => {\n    completenessService = new CompletenessService();\n  });\n\n  describe('calculateCompleteness', () => {\n    it('should return 0 for empty profile', () => {\n      const profile: any = {\n        id: 'profile-123',\n        userId: 'user-123',\n        displayName: '',\n        completeness: 0,\n        published: false,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      };\n\n      const score = completenessService.calculateCompleteness(profile);\n\n      expect(score).toBe(0);\n    });\n\n    it('should calculate correct score for partial profile', () => {\n      const profile: any = {\n        id: 'profile-123',\n        userId: 'user-123',\n        displayName: 'John Doe',\n        gender: 'male',\n        dob: new Date('1990-01-01'),\n        completeness: 0,\n        published: false,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      };\n\n      const score = completenessService.calculateCompleteness(profile);\n\n      expect(score).toBeGreaterThan(0);\n      expect(score).toBeLessThan(100);\n    });\n\n    it('should return 100 for complete profile', () => {\n      const profile: any = {\n        id: 'profile-123',\n        userId: 'user-123',\n        displayName: 'John Doe',\n        headline: 'Software Engineer from NYC',\n        about:\n          'I am a passionate software engineer with 5+ years of experience in building web applications.',\n        gender: 'male',\n        dob: new Date('1990-01-01'),\n        location: {\n          city: 'New York',\n          state: 'NY',\n          country: 'USA',\n        },\n        photos: [{ id: 'photo-1' }],\n        preferences: {\n          basic: { ageRange: { min: 25, max: 35 } },\n        },\n        completeness: 0,\n        published: false,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      };\n\n      const score = completenessService.calculateCompleteness(profile);\n\n      expect(score).toBe(100);\n    });\n  });\n\n  describe('canPublish', () => {\n    it('should return false and missing fields for incomplete profile', () => {\n      const profile: any = {\n        id: 'profile-123',\n        userId: 'user-123',\n        displayName: 'John Doe',\n        completeness: 0,\n        published: false,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      };\n\n      const result = completenessService.canPublish(profile);\n\n      expect(result.canPublish).toBe(false);\n      expect(result.missingFields.length).toBeGreaterThan(0);\n    });\n\n    it('should return true for complete profile', () => {\n      const profile: any = {\n        id: 'profile-123',\n        userId: 'user-123',\n        displayName: 'John Doe',\n        headline: 'Software Engineer from NYC',\n        about:\n          'I am a passionate software engineer with 5+ years of experience in building web applications.',\n        gender: 'male',\n        dob: new Date('1990-01-01'),\n        location: {\n          city: 'New York',\n          state: 'NY',\n          country: 'USA',\n        },\n        photos: [{ id: 'photo-1' }],\n        completeness: 100,\n        published: false,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      };\n\n      const result = completenessService.canPublish(profile);\n\n      expect(result.canPublish).toBe(true);\n      expect(result.missingFields.length).toBe(0);\n    });\n  });\n});\n\ndescribe('ProfilePermissions', () => {\n  let profilePermissions: ProfilePermissions;\n\n  beforeEach(() => {\n    profilePermissions = new ProfilePermissions();\n  });\n\n  describe('maskProfile', () => {\n    it('should not mask profile for owner', () => {\n      const profile: any = {\n        id: 'profile-123',\n        userId: 'user-123',\n        displayName: 'John Doe',\n        about: 'Full about section',\n        published: true,\n        completeness: 100,\n      };\n\n      const requester = {\n        userId: 'user-123',\n        isOwner: true,\n      };\n\n      const masked = profilePermissions.maskProfile(profile, requester);\n\n      expect(masked.about).toBe(profile.about);\n    });\n\n    it('should mask about for non-premium visitors', () => {\n      const longAbout = 'A'.repeat(200);\n\n      const profile: any = {\n        id: 'profile-123',\n        userId: 'user-123',\n        displayName: 'John Doe',\n        about: longAbout,\n        published: true,\n        completeness: 100,\n      };\n\n      const requester = {\n        userId: 'user-456',\n        isOwner: false,\n        isPremium: false,\n      };\n\n      const masked = profilePermissions.maskProfile(profile, requester);\n\n      expect(masked.about?.length).toBeLessThan(longAbout.length);\n      expect(masked.about).toContain('...');\n    });\n\n    it('should filter private photos for non-premium visitors', () => {\n      const profile: any = {\n        id: 'profile-123',\n        userId: 'user-123',\n        displayName: 'John Doe',\n        published: true,\n        completeness: 100,\n        photos: [\n          { id: 'photo-1', privacyLevel: 'public' },\n          { id: 'photo-2', privacyLevel: 'private' },\n        ],\n      };\n\n      const requester = {\n        userId: 'user-456',\n        isOwner: false,\n        isPremium: false,\n      };\n\n      const masked = profilePermissions.maskProfile(profile, requester);\n\n      expect(masked.photos?.length).toBe(1);\n      expect(masked.photos?.[0].privacyLevel).toBe('public');\n    });\n\n    it('should throw error for unpublished profile when not owner', () => {\n      const profile: any = {\n        id: 'profile-123',\n        userId: 'user-123',\n        displayName: 'John Doe',\n        published: false,\n        completeness: 50,\n      };\n\n      const requester = {\n        userId: 'user-456',\n        isOwner: false,\n      };\n\n      expect(() => profilePermissions.maskProfile(profile, requester)).toThrow(\n        'not published'\n      );\n    });\n  });\n});\n","size_bytes":10721},"src/modules/auth/auth.dto.ts":{"content":"import { z } from 'zod';\n\nexport const RegisterSchema = z.object({\n  email: z.string().email('Invalid email address'),\n  fullName: z.string().min(2, 'Full name must be at least 2 characters'),\n  phoneNumber: z\n    .string()\n    .regex(/^\\+?[1-9]\\d{1,14}$/, 'Invalid phone number format')\n    .optional(),\n  password: z.string().min(8, 'Password must be at least 8 characters'),\n});\n\nexport const VerifyOTPSchema = z.object({\n  email: z.string().email('Invalid email address'),\n  otp: z.string().length(6, 'OTP must be 6 digits').regex(/^\\d{6}$/, 'OTP must contain only digits'),\n});\n\nexport const LoginSchema = z.object({\n  email: z.string().email('Invalid email address'),\n  password: z.string().min(8, 'Password is required'),\n});\n\nexport const RefreshTokenSchema = z.object({\n  refreshToken: z.string().optional(),\n});\n\nexport type RegisterDTO = z.infer<typeof RegisterSchema>;\nexport type VerifyOTPDTO = z.infer<typeof VerifyOTPSchema>;\nexport type LoginDTO = z.infer<typeof LoginSchema>;\nexport type RefreshTokenDTO = z.infer<typeof RefreshTokenSchema>;\n","size_bytes":1059},"prisma/migrations/migration_lock.toml":{"content":"# Please do not edit this file manually\n# It should be added in your version-control system (e.g., Git)\nprovider = \"postgresql\"\n","size_bytes":128},"PATCH_UPDATE_SUMMARY.md":{"content":"# Auth Module Patch Update - Password + OTP 2-Step Login\n\n## Summary\n\nSuccessfully patched the authentication module to implement **email + password login with OTP 2-step verification**. Registration now requires a password, and login verifies the password before sending an OTP.\n\n---\n\n## Changes Made\n\n### 1. **Prisma Schema Update** âœ…\n\n**File:** `prisma/schema.prisma`\n\n**Change:** Added `passwordHash` field to User model\n\n```prisma\nmodel User {\n  id           String    @id @default(uuid())\n  email        String    @unique\n  fullName     String?\n  phoneNumber  String?\n  passwordHash String?   // NEW FIELD\n  isVerified   Boolean   @default(false)\n  otpHash      String?\n  otpExpiry    DateTime?\n  sessions     Session[]\n  createdAt    DateTime  @default(now())\n  updatedAt    DateTime  @updatedAt\n}\n```\n\n**Migration Required:** Run `npx prisma migrate dev --name add_password_hash`\n\n---\n\n### 2. **DTO/Validation Schema Updates** âœ…\n\n**File:** `src/modules/auth/auth.dto.ts`\n\n**Changes:**\n\n**RegisterSchema** - Now requires password:\n```typescript\nexport const RegisterSchema = z.object({\n  email: z.string().email('Invalid email address'),\n  fullName: z.string().min(2, 'Full name must be at least 2 characters'),\n  phoneNumber: z.string().regex(/^\\+?[1-9]\\d{1,14}$/, 'Invalid phone number format').optional(),\n  password: z.string().min(8, 'Password must be at least 8 characters'), // NEW\n});\n```\n\n**LoginSchema** - Now requires password:\n```typescript\nexport const LoginSchema = z.object({\n  email: z.string().email('Invalid email address'),\n  password: z.string().min(8, 'Password is required'), // NEW\n});\n```\n\n---\n\n### 3. **Email Service Implementation** âœ…\n\n**File:** `src/modules/auth/email.service.ts`\n\n**Change:** Implemented **real Nodemailer** integration (replacing stub)\n\n**Key Features:**\n- SMTP transporter with configurable host/port/auth\n- HTML email templates for OTP and welcome emails\n- Error handling with try-catch\n- Development mode OTP logging\n- Configurable `EMAIL_FROM` address\n\n**Configuration Required:**\n```env\nEMAIL_HOST=smtp.gmail.com\nEMAIL_PORT=587\nEMAIL_USER=your-email@gmail.com\nEMAIL_PASS=your-app-password\nEMAIL_FROM=\"Biye\" <noreply@biye.com>\n```\n\n---\n\n### 4. **Auth Service Updates** âœ…\n\n**File:** `src/modules/auth/auth.service.ts`\n\n#### **Registration Flow:**\n1. âœ… Hash password with bcrypt (10 rounds)\n2. âœ… Save `passwordHash` to database\n3. âœ… Generate OTP (6 digits)\n4. âœ… Hash OTP and save with expiry\n5. âœ… Send OTP email\n6. âœ… **NO auto-login** - user must verify OTP first\n\n**Code Changes:**\n```typescript\nconst passwordHash = await bcrypt.hash(password, 10);\n// Save passwordHash in user creation/update\n```\n\n#### **Login Flow:**\n1. âœ… Check if user exists and is verified\n2. âœ… Verify password with bcrypt.compare()\n3. âœ… If password matches â†’ generate OTP\n4. âœ… Save OTP hash + expiry\n5. âœ… Send OTP email\n6. âœ… Return `{ success: true, otpSent: true }`\n7. âœ… **NO tokens issued at login**\n\n**New Login Logic:**\n```typescript\nconst isPasswordValid = await bcrypt.compare(password, user.passwordHash);\nif (!isPasswordValid) {\n  throw new Error('Invalid email or password.');\n}\n// Then generate and send OTP\n```\n\n#### **Verification Flow (No Changes):**\n- Still accepts `{ email, otp }`\n- Issues access token + refresh token only after OTP verification\n- Creates session entry\n\n---\n\n### 5. **Auth Controller Updates** âœ…\n\n**File:** `src/modules/auth/auth.controller.ts`\n\n**Changes:**\n\n**Login Method:**\n```typescript\nasync login(req: Request, res: Response, next: NextFunction) {\n  const dto: LoginDTO = req.body; // Now includes { email, password }\n  const result = await authService.login(dto);\n  return successResponse(res, result, 'OTP sent to your email. Please verify to login.', 200);\n}\n```\n\n**Response Format:**\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"success\": true,\n    \"otpSent\": true\n  },\n  \"message\": \"OTP sent to your email. Please verify to login.\"\n}\n```\n\n---\n\n### 6. **Environment Variables** âœ…\n\n**File:** `.env.example`\n\n**New Variables Added:**\n```env\n# Email Configuration (SMTP)\nEMAIL_HOST=smtp.gmail.com\nEMAIL_PORT=587\nEMAIL_USER=your-email@gmail.com\nEMAIL_PASS=your-app-password\nEMAIL_FROM=\"Biye\" <noreply@biye.com>\n```\n\n---\n\n## Updated Authentication Flow\n\n### **Registration Flow:**\n```\n1. POST /api/v1/auth/register\n   Body: { email, fullName, phoneNumber, password }\n   \n2. Server:\n   - Hash password with bcrypt\n   - Save user with passwordHash\n   - Generate 6-digit OTP\n   - Hash OTP and save with expiry\n   - Send OTP email via Nodemailer\n   \n3. Response: { success: true, message: \"OTP sent...\" }\n\n4. POST /api/v1/auth/verify\n   Body: { email, otp }\n   \n5. Server:\n   - Validate OTP\n   - Mark user verified\n   - Create session\n   - Issue access + refresh tokens\n   \n6. Response: { accessToken, user }\n```\n\n### **Login Flow:**\n```\n1. POST /api/v1/auth/login\n   Body: { email, password }\n   \n2. Server:\n   - Find user by email\n   - Verify user is verified\n   - Compare password with bcrypt\n   - If valid â†’ generate OTP\n   - Send OTP email\n   \n3. Response: { success: true, otpSent: true }\n\n4. POST /api/v1/auth/verify\n   Body: { email, otp }\n   \n5. Server:\n   - Validate OTP\n   - Create new session\n   - Issue access + refresh tokens\n   \n6. Response: { accessToken, user }\n```\n\n---\n\n## API Endpoint Changes\n\n### **POST /api/v1/auth/register**\n**Before:**\n```json\n{\n  \"email\": \"user@example.com\",\n  \"fullName\": \"John Doe\",\n  \"phoneNumber\": \"+1234567890\"\n}\n```\n\n**After:**\n```json\n{\n  \"email\": \"user@example.com\",\n  \"fullName\": \"John Doe\",\n  \"phoneNumber\": \"+1234567890\",\n  \"password\": \"SecurePass123\"\n}\n```\n\n### **POST /api/v1/auth/login**\n**Before:**\n```json\n{\n  \"email\": \"user@example.com\"\n}\n```\n\n**After:**\n```json\n{\n  \"email\": \"user@example.com\",\n  \"password\": \"SecurePass123\"\n}\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"success\": true,\n    \"otpSent\": true\n  },\n  \"message\": \"OTP sent to your email. Please verify to login.\"\n}\n```\n\n### **POST /api/v1/auth/verify** (No Change)\n```json\n{\n  \"email\": \"user@example.com\",\n  \"otp\": \"123456\"\n}\n```\n\n---\n\n## Files Modified\n\n1. âœ… `prisma/schema.prisma` - Added passwordHash field\n2. âœ… `src/modules/auth/auth.dto.ts` - Updated validation schemas\n3. âœ… `src/modules/auth/email.service.ts` - Implemented Nodemailer\n4. âœ… `src/modules/auth/auth.service.ts` - Added password hashing/verification\n5. âœ… `src/modules/auth/auth.controller.ts` - Updated login response\n6. âœ… `.env.example` - Added email configuration\n\n---\n\n## Local Setup Steps\n\n### 1. Install Nodemailer (if not already installed)\n```bash\nnpm install nodemailer\nnpm install --save-dev @types/nodemailer\n```\n\n### 2. Update Environment Variables\n```bash\n# Edit .env and add:\nEMAIL_HOST=smtp.gmail.com\nEMAIL_PORT=587\nEMAIL_USER=your-email@gmail.com\nEMAIL_PASS=your-app-password\nEMAIL_FROM=\"Biye\" <noreply@biye.com>\n```\n\n**For Gmail:**\n- Use App Password instead of regular password\n- Enable 2FA on Gmail account\n- Generate App Password: https://myaccount.google.com/apppasswords\n\n### 3. Run Database Migration\n```bash\nnpx prisma migrate dev --name add_password_hash\n```\n\n### 4. Regenerate Prisma Client\n```bash\nnpx prisma generate\n```\n\n### 5. Start Development Server\n```bash\nnpm run dev\n```\n\n---\n\n## Testing the Changes\n\n### 1. Register a New User\n```bash\nPOST http://localhost:3000/api/v1/auth/register\nContent-Type: application/json\n\n{\n  \"email\": \"test@example.com\",\n  \"fullName\": \"Test User\",\n  \"password\": \"TestPass123\"\n}\n```\n\n**Expected:** OTP sent via email\n\n### 2. Verify Registration\n```bash\nPOST http://localhost:3000/api/v1/auth/verify\nContent-Type: application/json\n\n{\n  \"email\": \"test@example.com\",\n  \"otp\": \"123456\"\n}\n```\n\n**Expected:** Access token + user data returned\n\n### 3. Login with Password\n```bash\nPOST http://localhost:3000/api/v1/auth/login\nContent-Type: application/json\n\n{\n  \"email\": \"test@example.com\",\n  \"password\": \"TestPass123\"\n}\n```\n\n**Expected:** `{ otpSent: true }` and OTP sent via email\n\n### 4. Verify Login OTP\n```bash\nPOST http://localhost:3000/api/v1/auth/verify\nContent-Type: application/json\n\n{\n  \"email\": \"test@example.com\",\n  \"otp\": \"654321\"\n}\n```\n\n**Expected:** New access token + session created\n\n---\n\n## Security Notes\n\nâœ… Passwords hashed with bcrypt (10 rounds)  \nâœ… OTPs hashed with bcrypt before storage  \nâœ… Password never stored in plain text  \nâœ… Password never logged  \nâœ… Rate limiting still active (3 OTP/15min per email)  \nâœ… OTP still expires after 5 minutes  \nâœ… Failed password attempts logged for monitoring  \n\n---\n\n## Breaking Changes\n\nâš ï¸ **BREAKING:** Registration now requires `password` field  \nâš ï¸ **BREAKING:** Login now requires `password` field  \nâš ï¸ **BREAKING:** Old users without passwordHash cannot login (need password reset flow)  \n\n---\n\n## What Was NOT Changed\n\nâœ… Token system (access + refresh tokens)  \nâœ… Session management  \nâœ… Token rotation logic  \nâœ… Refresh endpoint  \nâœ… Logout endpoint  \nâœ… /me endpoint  \nâœ… Rate limiting rules  \nâœ… OTP verification flow  \n\n---\n\n## Next Steps (Optional)\n\n1. **Password Reset Flow** - Allow users to reset forgotten passwords\n2. **Email Templates** - Improve email HTML design\n3. **Email Provider** - Switch to SendGrid/AWS SES for production\n4. **Password Strength Meter** - Add frontend validation\n5. **Account Recovery** - Implement backup email/phone\n","size_bytes":9348},"src/modules/auth/auth.service.ts":{"content":"import { PrismaClient } from '@prisma/client';\nimport bcrypt from 'bcryptjs';\nimport { randomInt } from 'crypto';\nimport { RegisterDTO, VerifyOTPDTO, LoginDTO } from './auth.dto.js';\nimport { emailService } from './email.service.js';\nimport { tokenService } from './token.service.js';\nimport { sessionService } from './session.service.js';\nimport { AuthResponse, SessionInfo, UserResponse } from './auth.types.js';\nimport { logger } from '../../utils/logger.js';\nimport { redis } from '../../config/redis.js';\n\nconst prisma = new PrismaClient();\n\nconst OTP_RATE_LIMIT_PREFIX = 'otp_rate_limit:';\nconst OTP_RATE_LIMIT_MAX = 5;\nconst OTP_RATE_LIMIT_WINDOW = 900;\nconst OTP_EXPIRY_MINUTES = 5;\n\nexport class AuthService {\n  async register(dto: RegisterDTO): Promise<{ success: boolean; message: string }> {\n    const { email, fullName, phoneNumber, password } = dto;\n\n    await this.checkOTPRateLimit(email);\n\n    let user = await prisma.user.findUnique({ where: { email } });\n\n    if (user && user.isVerified) {\n      throw new Error('User already exists and is verified. Please login instead.');\n    }\n\n    const passwordHash = await bcrypt.hash(password, 10);\n    const otp = this.generateOTP();\n    const otpHash = await bcrypt.hash(otp, 10);\n    const otpExpiry = new Date(Date.now() + OTP_EXPIRY_MINUTES * 60 * 1000);\n\n    if (user && !user.isVerified) {\n      await prisma.user.update({\n        where: { email },\n        data: {\n          fullName: fullName || user.fullName,\n          phoneNumber: phoneNumber || user.phoneNumber,\n          passwordHash,\n          otpHash,\n          otpExpiry,\n        },\n      });\n\n      logger.info('Resending OTP to unverified user', { email });\n    } else {\n      await prisma.user.create({\n        data: {\n          email,\n          fullName,\n          phoneNumber,\n          passwordHash,\n          isVerified: false,\n          otpHash,\n          otpExpiry,\n        },\n      });\n\n      logger.info('New user registration initiated', { email });\n    }\n\n    await emailService.sendOTP(email, otp, 'register');\n\n    await this.incrementOTPRateLimit(email);\n\n    return {\n      success: true,\n      message: 'OTP sent to your email. Please verify to complete registration.',\n    };\n  }\n\n  async verify(dto: VerifyOTPDTO, sessionInfo: SessionInfo): Promise<AuthResponse> {\n    const { email, otp } = dto;\n\n    const user = await prisma.user.findUnique({ where: { email } });\n\n    if (!user || !user.otpHash || !user.otpExpiry) {\n      throw new Error('Invalid verification request. Please request a new OTP.');\n    }\n\n    if (new Date() > user.otpExpiry) {\n      throw new Error('OTP has expired. Please request a new one.');\n    }\n\n    const isOTPValid = await bcrypt.compare(otp, user.otpHash);\n\n    if (!isOTPValid) {\n      logger.warn('Invalid OTP attempt', { email });\n      throw new Error('Invalid OTP. Please try again.');\n    }\n\n    await prisma.user.update({\n      where: { email },\n      data: {\n        isVerified: true,\n        otpHash: null,\n        otpExpiry: null,\n      },\n    });\n\n    logger.info('User verified successfully', { email, userId: user.id });\n\n    const sessionId = await sessionService.createSession(user.id, sessionInfo);\n\n    const accessToken = tokenService.generateAccessToken(user.id, user.email, sessionId);\n    const refreshToken = await tokenService.generateRefreshToken(user.id, sessionId);\n\n    if (!user.isVerified) {\n      await emailService.sendWelcomeEmail(email, user.fullName || undefined);\n    }\n\n    return {\n      accessToken,\n      refreshToken,\n      user: this.sanitizeUser(user),\n    };\n  }\n\n  async login(dto: LoginDTO): Promise<{ success: boolean; otpSent: boolean }> {\n    const { email, password } = dto;\n\n    await this.checkOTPRateLimit(email);\n\n    const user = await prisma.user.findUnique({ where: { email } });\n\n    if (!user) {\n      throw new Error('User not found. Please register first.');\n    }\n\n    if (!user.isVerified) {\n      throw new Error('User not verified. Please complete registration first.');\n    }\n\n    if (!user.passwordHash) {\n      throw new Error('Password not set for this user. Please contact support.');\n    }\n\n    const isPasswordValid = await bcrypt.compare(password, user.passwordHash);\n\n    if (!isPasswordValid) {\n      logger.warn('Invalid password attempt', { email });\n      throw new Error('Invalid email or password.');\n    }\n\n    const otp = this.generateOTP();\n    const otpHash = await bcrypt.hash(otp, 10);\n    const otpExpiry = new Date(Date.now() + OTP_EXPIRY_MINUTES * 60 * 1000);\n\n    await prisma.user.update({\n      where: { email },\n      data: { otpHash, otpExpiry },\n    });\n\n    await emailService.sendOTP(email, otp, 'login');\n\n    await this.incrementOTPRateLimit(email);\n\n    logger.info('Login OTP sent', { email });\n\n    return {\n      success: true,\n      otpSent: true,\n    };\n  }\n\n  async refresh(refreshToken: string, sessionInfo: SessionInfo): Promise<AuthResponse> {\n    const tokenData = await tokenService.verifyRefreshToken(refreshToken);\n\n    const isSessionValid = await sessionService.isSessionValid(tokenData.sessionId);\n    if (!isSessionValid) {\n      throw new Error('Session has been revoked. Please login again.');\n    }\n\n    const user = await prisma.user.findUnique({\n      where: { id: tokenData.userId },\n    });\n\n    if (!user) {\n      throw new Error('User not found');\n    }\n\n    await sessionService.updateSessionActivity(tokenData.sessionId);\n\n    const newRefreshToken = await tokenService.rotateRefreshToken(\n      refreshToken,\n      tokenData.userId,\n      tokenData.sessionId\n    );\n\n    const accessToken = tokenService.generateAccessToken(\n      user.id,\n      user.email,\n      tokenData.sessionId\n    );\n\n    logger.info('Tokens refreshed', { userId: user.id, sessionId: tokenData.sessionId });\n\n    return {\n      accessToken,\n      refreshToken: newRefreshToken,\n      user: this.sanitizeUser(user),\n    };\n  }\n\n  async logout(refreshToken: string, sessionId: string): Promise<void> {\n    await tokenService.invalidateRefreshToken(refreshToken);\n    await sessionService.revokeSession(sessionId);\n\n    logger.info('User logged out', { sessionId });\n  }\n\n  async getMe(userId: string): Promise<UserResponse> {\n    const user = await prisma.user.findUnique({\n      where: { id: userId },\n    });\n\n    if (!user) {\n      throw new Error('User not found');\n    }\n\n    return this.sanitizeUser(user);\n  }\n\n  private generateOTP(): string {\n    return randomInt(100000, 999999).toString();\n  }\n\n  private async checkOTPRateLimit(email: string): Promise<void> {\n    const key = `${OTP_RATE_LIMIT_PREFIX}${email}`;\n    const count = await redis.get(key);\n\n    if (count && parseInt(count, 10) >= OTP_RATE_LIMIT_MAX) {\n      throw new Error('Too many OTP requests. Please try again in 15 minutes.');\n    }\n  }\n\n  private async incrementOTPRateLimit(email: string): Promise<void> {\n    const key = `${OTP_RATE_LIMIT_PREFIX}${email}`;\n    const current = await redis.get(key);\n\n    if (current) {\n      await redis.incr(key);\n    } else {\n      await redis.setex(key, OTP_RATE_LIMIT_WINDOW, '1');\n    }\n  }\n\n  private sanitizeUser(user: any): UserResponse {\n    return {\n      id: user.id,\n      email: user.email,\n      fullName: user.fullName,\n      phoneNumber: user.phoneNumber,\n      isVerified: user.isVerified,\n      createdAt: user.createdAt,\n    };\n  }\n}\n\nexport const authService = new AuthService();\n","size_bytes":7397},"src/utils/response.ts":{"content":"import { Response } from 'express';\n\nexport interface SuccessResponse<T = any> {\n  success: true;\n  data: T;\n  message?: string;\n}\n\nexport interface ErrorResponse {\n  success: false;\n  error: {\n    message: string;\n    code?: string;\n    details?: any;\n  };\n}\n\nexport function sendSuccess<T>(res: Response, data: T, message?: string, statusCode = 200): Response {\n  const response: SuccessResponse<T> = {\n    success: true,\n    data,\n  };\n\n  if (message) {\n    response.message = message;\n  }\n\n  return res.status(statusCode).json(response);\n}\n\nexport function sendError(\n  res: Response,\n  message: string,\n  statusCode = 500,\n  code?: string,\n  details?: any\n): Response {\n  const response: ErrorResponse = {\n    success: false,\n    error: {\n      message,\n      code,\n      details,\n    },\n  };\n\n  return res.status(statusCode).json(response);\n}\n","size_bytes":849},"src/modules/auth/session.service.ts":{"content":"import { PrismaClient } from '@prisma/client';\nimport { SessionInfo } from './auth.types.js';\nimport { logger } from '../../utils/logger.js';\n\nconst prisma = new PrismaClient();\n\nexport class SessionService {\n  async createSession(userId: string, sessionInfo: SessionInfo): Promise<string> {\n    const session = await prisma.session.create({\n      data: {\n        userId,\n        deviceId: sessionInfo.deviceId,\n        ip: sessionInfo.ip,\n        userAgent: sessionInfo.userAgent,\n        revoked: false,\n      },\n    });\n\n    logger.info('Session created', { userId, sessionId: session.id });\n\n    return session.id;\n  }\n\n  async updateSessionActivity(sessionId: string): Promise<void> {\n    await prisma.session.update({\n      where: { id: sessionId },\n      data: { lastSeenAt: new Date() },\n    });\n  }\n\n  async revokeSession(sessionId: string): Promise<void> {\n    await prisma.session.update({\n      where: { id: sessionId },\n      data: { revoked: true },\n    });\n\n    logger.info('Session revoked', { sessionId });\n  }\n\n  async revokeAllUserSessions(userId: string): Promise<void> {\n    await prisma.session.updateMany({\n      where: { userId, revoked: false },\n      data: { revoked: true },\n    });\n\n    logger.info('All user sessions revoked', { userId });\n  }\n\n  async getActiveSessions(userId: string) {\n    return prisma.session.findMany({\n      where: { userId, revoked: false },\n      orderBy: { lastSeenAt: 'desc' },\n    });\n  }\n\n  async isSessionValid(sessionId: string): Promise<boolean> {\n    const session = await prisma.session.findUnique({\n      where: { id: sessionId },\n    });\n\n    return session !== null && !session.revoked;\n  }\n\n  async getSessionById(sessionId: string) {\n    return prisma.session.findUnique({\n      where: { id: sessionId },\n    });\n  }\n}\n\nexport const sessionService = new SessionService();\n","size_bytes":1841},"src/middleware/validate.ts":{"content":"import { Request, Response, NextFunction } from 'express';\nimport { AnyZodObject, ZodError } from 'zod';\nimport { sendError } from '../utils/response.js';\n\nexport function validate(schema: AnyZodObject) {\n  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    try {\n      await schema.parseAsync(\n        req.body\n      );\n      next();\n    } catch (error) {\n      if (error instanceof ZodError) {\n        sendError(\n          res,\n          'Validation failed',\n          400,\n          'VALIDATION_ERROR',\n          error.errors\n        );\n        return;\n      }\n      next(error);\n    }\n  };\n}\n","size_bytes":632},"src/modules/profile/profile.permissions.ts":{"content":"import { ProfileData, MaskedProfile, RequesterContext, PhotoData } from './profile.types.js';\nimport { logger } from '../../utils/logger.js';\n\nexport class ProfilePermissions {\n  maskProfile(profile: ProfileData, requester: RequesterContext): MaskedProfile {\n    const isOwner = requester.userId === profile.userId;\n    const isGuardian = requester.isGuardian || false;\n    const isPremium = requester.isPremium || false;\n\n    const age = profile.dob ? this.calculateAge(profile.dob) : undefined;\n\n    const maskedProfile: MaskedProfile = {\n      id: profile.id,\n      displayName: profile.displayName,\n      completeness: profile.completeness,\n    };\n\n    if (isOwner) {\n      return {\n        ...maskedProfile,\n        headline: profile.headline,\n        about: profile.about,\n        gender: profile.gender,\n        age,\n        location: profile.location,\n        photos: profile.photos,\n        preferences: profile.preferences,\n      };\n    }\n\n    if (!profile.published) {\n      logger.warn('Attempted to view unpublished profile', {\n        profileId: profile.id,\n        requesterId: requester.userId,\n      });\n      throw new Error('Profile is not published');\n    }\n\n    if (isGuardian || isPremium) {\n      maskedProfile.headline = profile.headline;\n      maskedProfile.about = profile.about;\n      maskedProfile.gender = profile.gender;\n      maskedProfile.age = age;\n      maskedProfile.location = this.maskLocation(profile.location);\n      maskedProfile.photos = this.filterPhotos(profile.photos || [], 'all');\n      maskedProfile.preferences = profile.preferences;\n    } else {\n      maskedProfile.headline = profile.headline;\n      maskedProfile.about = this.maskAbout(profile.about);\n      maskedProfile.gender = profile.gender;\n      maskedProfile.age = age;\n      maskedProfile.location = this.maskLocation(profile.location);\n      maskedProfile.photos = this.filterPhotos(profile.photos || [], 'public');\n    }\n\n    return maskedProfile;\n  }\n\n  canViewProfile(profile: ProfileData, requester: RequesterContext): boolean {\n    const isOwner = requester.userId === profile.userId;\n\n    if (isOwner) {\n      return true;\n    }\n\n    if (!profile.published) {\n      return false;\n    }\n\n    return true;\n  }\n\n  canEditProfile(profile: ProfileData, requester: RequesterContext): boolean {\n    return requester.userId === profile.userId;\n  }\n\n  canPublishProfile(profile: ProfileData, requester: RequesterContext): boolean {\n    return requester.userId === profile.userId;\n  }\n\n  private calculateAge(dob: Date): number {\n    const today = new Date();\n    const birthDate = new Date(dob);\n    let age = today.getFullYear() - birthDate.getFullYear();\n    const monthDiff = today.getMonth() - birthDate.getMonth();\n\n    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {\n      age--;\n    }\n\n    return age;\n  }\n\n  private maskAbout(about?: string): string | undefined {\n    if (!about) return undefined;\n\n    if (about.length <= 150) {\n      return about;\n    }\n\n    return about.substring(0, 150) + '...';\n  }\n\n  private maskLocation(location: any): any {\n    if (!location || typeof location !== 'object') {\n      return undefined;\n    }\n\n    return {\n      city: location.city,\n      state: location.state,\n      country: location.country,\n    };\n  }\n\n  private filterPhotos(photos: PhotoData[], level: 'public' | 'all'): PhotoData[] {\n    if (level === 'all') {\n      return photos;\n    }\n\n    return photos.filter((photo) => photo.privacyLevel === 'public');\n  }\n}\n\nexport const profilePermissions = new ProfilePermissions();\n","size_bytes":3576},"src/modules/profile/profile.controller.ts":{"content":"import { Request, Response, NextFunction } from 'express';\nimport { profileService } from './profile.service.js';\nimport { profilePermissions } from './profile.permissions.js';\nimport { CreateProfileDTO, StepUpdateDTO } from './profile.dto.js';\nimport { RequesterContext } from './profile.types.js';\nimport { sendSuccess } from '../../utils/response.js';\nimport { logger } from '../../utils/logger.js';\n\nexport class ProfileController {\n  async createProfile(req: Request, res: Response, next: NextFunction) {\n    try {\n      const userId = (req as any).userId;\n      const dto: CreateProfileDTO = req.body;\n\n      const profile = await profileService.createProfile(userId, dto);\n\n      return sendSuccess(res, profile, 'Profile created successfully', 201);\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async getMyProfile(req: Request, res: Response, next: NextFunction) {\n    try {\n      const userId = (req as any).userId;\n\n      const profile = await profileService.getMyProfile(userId);\n\n      if (!profile) {\n        return sendSuccess(res, null, 'No profile found', 404);\n      }\n\n      return sendSuccess(res, profile, 'Profile retrieved successfully', 200);\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async getProfileById(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params;\n      const userId = (req as any).userId;\n\n      const requester: RequesterContext = {\n        userId,\n        isOwner: false,\n        isGuardian: false,\n        isPremium: false,\n      };\n\n      const profile = await profileService.getProfileById(id, requester);\n\n      const maskedProfile = profilePermissions.maskProfile(profile, requester);\n\n      return sendSuccess(res, maskedProfile, 'Profile retrieved successfully', 200);\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async updateProfileStep(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params;\n      const userId = (req as any).userId;\n      const stepData: StepUpdateDTO = req.body;\n\n      const profile = await profileService.updateProfileStep(id, userId, stepData);\n\n      return sendSuccess(res, profile, 'Profile step updated successfully', 200);\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async publishProfile(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params;\n      const userId = (req as any).userId;\n\n      const profile = await profileService.publishProfile(id, userId);\n\n      return sendSuccess(res, profile, 'Profile published successfully', 200);\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async unpublishProfile(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params;\n      const userId = (req as any).userId;\n\n      const profile = await profileService.unpublishProfile(id, userId);\n\n      return sendSuccess(res, profile, 'Profile unpublished successfully', 200);\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async deleteProfile(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params;\n      const userId = (req as any).userId;\n\n      await profileService.softDeleteProfile(id, userId);\n\n      return sendSuccess(res, null, 'Profile deleted successfully', 200);\n    } catch (error) {\n      next(error);\n    }\n  }\n}\n\nexport const profileController = new ProfileController();\n","size_bytes":3393},"src/middleware/helmet.ts":{"content":"import helmet from 'helmet';\n\nexport const helmetMiddleware = helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n      scriptSrc: [\"'self'\"],\n      imgSrc: [\"'self'\", 'data:', 'https:'],\n    },\n  },\n  hsts: {\n    maxAge: 31536000,\n    includeSubDomains: true,\n    preload: true,\n  },\n  frameguard: {\n    action: 'deny',\n  },\n  noSniff: true,\n  xssFilter: true,\n});\n","size_bytes":445},"src/routes/health.route.ts":{"content":"import { Router, Request, Response } from 'express';\nimport { sendSuccess } from '../utils/response.js';\n\nconst router = Router();\n\nconst startTime = Date.now();\n\nrouter.get('/health', (_req: Request, res: Response) => {\n  const uptime = Math.floor((Date.now() - startTime) / 1000);\n  \n  sendSuccess(res, {\n    status: 'ok',\n    uptime: `${uptime}s`,\n    timestamp: new Date().toISOString(),\n  });\n});\n\nexport default router;\n","size_bytes":426}},"version":2}